{"version":3,"sources":["nextjournal/clojure_mode.cljs"],"mappings":";;;;AAcA,AAAKA,2CACH,iBAAMC,YAAU,WAASC;AAAT,AAAA,iBAAyB,6CAAA,5CAAK,AAACC,oCAAQD,oBAChB,2CAAA,1CAAK,AAACE,kCAAMF;;AADnD,AAEE,kBACUD,gBACHA,iBACCA;;AAEZ,AAAKI,sCACH,qBAAA,wCAAA,mEAAA,iDAAA,WAAA,iBAAA,gBAAA,yDAAA,2DAAA,yDAAA,wDAAA,uEAAA,kBAAA,8DAAA,0DAAA,npBAACC,8wBAAa,AAAWC,4wBACN,AAAWA,lIACF,AAAWA,zgBACZ,AAAaA,oEAAK,AAAgBA,yIAC1C,AAAQA,lEACD,AAAYA,+bAClB,AAAWA,jQACb,AAAUA,gIACH,AAAUA,zgBAGd,AAAUA,2UACZ,AAAQA,icACZ,AAAQA,l5BACA,AAAeA,+kBACpB,AAAUA;AAE9B,AAAKC,kCAAOC;AAEZ,AAQA,AAAA,kCAAA,0CAAAC,5EAAME;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC;;;KAAA;AAAA,OAAAA,8DAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAC,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,gEAAA,hEAAMD;AAAN,AACM,OAACE,8DAAON;;;AADd,CAAA,gEAAA,hEAAMI,2EAEEG;AAFR,AAGG,iFAAA,1EAASC,sFACa,iBAAA,WAAA,5BAAYD,6BAAwBE,qDACA,AAAMC,yEAAsBlB,0CAC5B,AAACmB,8DAAoBd;;;AANlF,CAAA,0DAAA,1DAAMO;;AAAN,AAQA,AAAeQ,2CAAgBC;AAC/B,AAAeC,0CAAeC;AAC9B,AAAeC,0CAAeC;AAE9B,8CAAA,9CAAKC,+CACC,AAACZ,8DAAOL,sEACR,AAACkB,+DACD,AAACC,+DACD,AAACC,kEACD,AAACC,0EACD,0DAAA,2CAAA,6DAAA,lKAACC;AAEP;;;;AAAKC,4CAGH,KAAAC,wEAAkB,AAACnB,gEAAQ,kDAAA,lDAAIY;AAEjC","names":["nextjournal.clojure-mode/fold-node-props","coll-span","tree","nextjournal.clojure-mode.node/start","nextjournal.clojure-mode.node/end","nextjournal.clojure-mode/style-tags","cljs.core/clj->js","js/module$node_modules$$lezer$highlight$dist$index_cjs.tags","nextjournal.clojure-mode/parser","js/module$node_modules$$nextjournal$lezer_clojure$dist$index_cjs.parser","var_args","G__60701","nextjournal.clojure-mode/syntax","js/Error","nextjournal.clojure_mode.syntax","parser","js/module$node_modules$$codemirror$language$dist$index_cjs.LRLanguage","nextjournal.clojure-mode.extensions.formatting/props","js/module$node_modules$$codemirror$language$dist$index_cjs.foldNodeProp","js/module$node_modules$$lezer$highlight$dist$index_cjs.styleTags","nextjournal.clojure-mode/complete-keymap","nextjournal.clojure-mode.keymap/complete","nextjournal.clojure-mode/builtin-keymap","nextjournal.clojure-mode.keymap/builtin","nextjournal.clojure-mode/paredit-keymap","nextjournal.clojure-mode.keymap/paredit","nextjournal.clojure-mode/default-extensions","nextjournal.clojure-mode.extensions.close-brackets/extension","nextjournal.clojure-mode.extensions.match-brackets/extension","nextjournal.clojure-mode.extensions.selection-history/extension","nextjournal.clojure-mode.extensions.formatting/ext-format-changed-lines","nextjournal.clojure-mode.extensions.eval-region/extension","nextjournal.clojure-mode/language-support","js/module$node_modules$$codemirror$language$dist$index_cjs.LanguageSupport"],"sourcesContent":["(ns nextjournal.clojure-mode\r\n  (:require [\"@lezer/highlight\" :as highlight :refer [tags]]\r\n            [\"@codemirror/language\" :as language :refer [LRLanguage LanguageSupport]]\r\n            [\"@nextjournal/lezer-clojure\" :as lezer-clj]\r\n            [applied-science.js-interop :as j]\r\n            [nextjournal.clojure-mode.extensions.close-brackets :as close-brackets]\r\n            [nextjournal.clojure-mode.extensions.match-brackets :as match-brackets]\r\n            [nextjournal.clojure-mode.extensions.formatting :as format]\r\n            [nextjournal.clojure-mode.extensions.selection-history :as sel-history]\r\n            [nextjournal.clojure-mode.extensions.eval-region :as eval-region]\r\n            [nextjournal.clojure-mode.keymap :as keymap]\r\n            [nextjournal.clojure-mode.node :as n]\r\n            [nextjournal.clojure-mode.test-utils :as test-utils]))\r\n\r\n(def fold-node-props\r\n  (let [coll-span (fn [^js tree] #js{:from (inc (n/start tree))\r\n                                     :to (dec (n/end tree))})]\r\n    (j/lit\r\n     {:Vector coll-span\r\n      :Map coll-span\r\n      :List coll-span})))\r\n\r\n(def style-tags\r\n  (clj->js {:NS (.-keyword tags)\r\n            :DefLike (.-keyword tags)\r\n            \"Operator/Symbol\" (.-keyword tags)\r\n            \"VarName/Symbol\" (.definition tags (.-variableName tags))\r\n            :Boolean (.-atom tags)\r\n            \"DocString/...\" (.-emphasis tags)\r\n            :Discard! (.-comment tags)\r\n            :Number (.-number tags)\r\n            :StringContent (.-string tags)\r\n            ;; need to pass something, that returns \" when being parsed as JSON\r\n            ;; also #js doesn't treat this correctly, hence clj->js above\r\n            \"\\\"\\\\\\\"\\\"\" (.-string tags)\r\n            :Keyword (.-atom tags)\r\n            :Nil (.-null tags)\r\n            :LineComment (.-lineComment tags)\r\n            :RegExp (.-regexp tags)}))\r\n\r\n(def parser lezer-clj/parser)\r\n\r\n(comment\r\n  ;; to build a parser \\\"\"live\" from a .grammar file,\r\n  ;; rather than using a precompiled parser:\r\n  (def parser\r\n    (lg/buildParser\r\n     (shadow.resource/inline \"./clojure/clojure.grammar\")\r\n     #js{:externalProp n/node-prop})))\r\n\r\n(defn syntax\r\n  ([] (syntax parser))\r\n  ([^js parser]\r\n   (.define LRLanguage\r\n            #js {:parser (.configure parser #js {:props #js [format/props\r\n                                                             (.add language/foldNodeProp fold-node-props)\r\n                                                             (highlight/styleTags style-tags)]})})))\r\n\r\n(def ^js/Array complete-keymap keymap/complete)\r\n(def ^js/Array builtin-keymap keymap/builtin)\r\n(def ^js/Array paredit-keymap keymap/paredit)\r\n\r\n(def default-extensions\r\n  #js[(syntax lezer-clj/parser)\r\n      (close-brackets/extension)\r\n      (match-brackets/extension)\r\n      (sel-history/extension)\r\n      (format/ext-format-changed-lines)\r\n      (eval-region/extension {:modifier \"Alt\"})])\r\n\r\n(def language-support\r\n  \"Eases embedding clojure mode into other languages (e.g. markdown).\r\n  See https://codemirror.net/docs/ref/#language.LanguageSupport for motivations\"\r\n  (LanguageSupport. (syntax) (.. default-extensions (slice 1))))\r\n\r\n(comment\r\n\r\n  (let [state (test-utils/make-state #js[(syntax lezer-clj/parser)] \"[] a\")]\r\n    (-> (n/tree state)\r\n        (.resolve 2 1) ;; Symbol \"a\"\r\n        .-prevSibling\r\n        js/console.log))\r\n\r\n  (let [state (test-utils/make-state #js[(syntax lezer-clj/parser)] \"\\\"\\\" :a\")]\r\n    (-> state\r\n        n/tree\r\n        (n/cursor 0 1)\r\n        ))\r\n  (let [state (test-utils/make-state #js[(syntax lezer-clj/parser)] \"a\\n\\nb\")]\r\n    (-> state\r\n        (n/tree 1 1)\r\n        (->> (n/string state))\r\n        str\r\n        ))\r\n  (let [state (test-utils/make-state #js[(syntax lezer-clj/parser)] \"([]| s)\")]\r\n    (-> state\r\n        n/tree\r\n        (n/terminal-cursor 3 1)\r\n        ))\r\n\r\n  (let [state (test-utils/make-state #js[(syntax lezer-clj/parser)] \"(|\")]\r\n    (-> state\r\n        (close-brackets/handle-close \")\")\r\n        (->> (n/string state)))))\r\n"]}