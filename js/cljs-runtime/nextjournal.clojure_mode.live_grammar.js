goog.provide('nextjournal.clojure_mode.live_grammar');
var module$node_modules$$lezer$generator$dist$index_cjs=shadow.js.require("module$node_modules$$lezer$generator$dist$index_cjs", {});
nextjournal.clojure_mode.live_grammar.parser = module$node_modules$$lezer$generator$dist$index_cjs.buildParser("@external prop prefixColl from \"./props\"\r\n@external prop coll from \"./props\"\r\n@external prop prefixEdge from \"./props\"\r\n@external prop sameEdge from \"./props\"\r\n@external prop prefixContainer from \"./props\"\r\n\r\n@top Program { expression* }\r\n\r\n@skip { whitespace | LineComment | Discard }\r\n\r\nexpression { Boolean | Nil | Deref | Quote | SyntaxQuote | Unquote | UnquoteSplice | Symbol | Number | Keyword | List | Vector | Map | String | Character | Set | NamespacedMap | RegExp | Var | ReaderConditional | SymbolicValue | AnonymousFunction | Meta<expression> | TaggedLiteral<expression> | ConstructorCall }\r\nDiscard { \"#_\" expression }\r\n@precedence { docString @left, operator @left, meta @right}\r\n\r\nlistContents {\r\n   defList { defLikeWithMeta varNameWithMeta (DocString expression+ | expression+)? } |\r\n   nsList { nsWithMeta varNameWithMeta (DocString expression* | expression*) } |\r\n   anyList { operatorWithMeta? expression* }\r\n }\r\n\r\nDocString { !docString String }\r\nList[coll] { \"(\" listContents \")\" }\r\nVector[coll] { \"[\" expression* \"]\" }\r\nMap[coll] { \"{\" expression* \"}\" }\r\nVarName { Symbol }\r\n\r\n@skip {} {\r\n  ReaderTag { \"#\" readerTagIdent }\r\n  ConstructorPrefix[prefixEdge] { \"#\" qualifiedJavaIdent }\r\n\r\n  SymbolicValue { \"##\" ident }\r\n  Set[prefixColl] { \"#\" Map }\r\n  AnonymousFunction[prefixColl] { \"#\" List }\r\n\r\n  KeywordPrefix[prefixEdge] { \"#\" keyword }\r\n  NamespacedMap[prefixColl] { KeywordPrefix Map }\r\n\r\n  RegExp[prefixColl] { \"#\" String }\r\n  Var[prefixColl] { \"#'\" Symbol }\r\n  ReaderConditional[prefixColl] { \"#?\" (List | Deref) }\r\n  ReaderMetadata[prefixColl] { \"#^\" expression }\r\n  Metadata[prefixColl] { \"^\" expression }\r\n  String { '\"' StringContent? '\"' }\r\n}\r\n\r\nMeta[prefixContainer]<t> { (Metadata | ReaderMetadata) !meta t }\r\nTaggedLiteral[prefixContainer]<t> { ReaderTag t }\r\n\r\n// https://clojure.org/reference/reader#_deftype_defrecord_and_constructor_calls_version_1_3_and_later\r\nConstructorCall[prefixContainer] { ConstructorPrefix (Map | Vector) }\r\n\r\nDeref[prefixColl] { \"@\" expression }\r\nQuote[prefixColl] { \"'\" expression }\r\nSyntaxQuote[prefixColl] { \"`\" expression }\r\nUnquote[prefixColl] { \"~\" expression }\r\nUnquoteSplice[prefixColl] { \"~@\" expression }\r\noperatorWithMeta { Operator | Meta<operatorWithMeta> }\r\ndefLikeWithMeta { DefLike | Meta<defLikeWithMeta> }\r\nnsWithMeta { NS | Meta<nsWithMeta> }\r\nvarNameWithMeta { VarName | Meta<varNameWithMeta> }\r\n\r\nOperator { !operator Symbol }\r\n\r\n@tokens {\r\n\r\n\r\n  \"[\"\r\n  \"{\"\r\n  \"(\"\r\n\r\n  \"#\"[prefixEdge]\r\n  \"##\"[prefixEdge]\r\n  \"#'\"[prefixEdge]\r\n  \"#?\"[prefixEdge]\r\n  \"#^\"[prefixEdge]\r\n  \"#_\"[prefixEdge]\r\n\r\n  '\"'[sameEdge, closedBy='\"', openedBy='\"']\r\n  \"'\"[prefixEdge]\r\n  \"`\"[prefixEdge]\r\n  \"~\"[prefixEdge]\r\n  \"~@\"[prefixEdge]\r\n  \"^\"[prefixEdge]\r\n  \"@\"[prefixEdge]\r\n\r\n\r\n  \"]\"\r\n  \"}\"\r\n  \")\"\r\n\r\n  whitespace { (std.whitespace | \",\")+ }\r\n\r\n  LineComment { \";\" ![\\n]* }\r\n\r\n  // https://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.8\r\n  // class or constructor names\r\n  javaIdentStart { std.asciiLetter | \"_\" | \"$\" | $[\\u{a1}-\\u{10ff}] }\r\n  javaIdentChar { javaIdentStart | std.digit }\r\n  javaIdent { javaIdentStart javaIdentChar* }\r\n  qualifiedJavaIdent { javaIdent (\".\" javaIdent)+ }\r\n\r\n  // reader tags cannot contain dots\r\n  readerTagIdentStart { std.asciiLetter | $[<>&%_=?!*+\\-$\\u{a1}-\\u{10ff}] }\r\n  readerTagIdentChar { readerTagIdentStart | \"/\" | std.digit }\r\n  readerTagIdent { readerTagIdentStart readerTagIdentChar* }\r\n\r\n  identStart { std.asciiLetter | $[<>&%._=?!*+\\-$\\u{a1}-\\u{10ff}/] }\r\n  identChar { identStart | std.digit | \":\" | \"'\" | \"#\" | \"/\"}\r\n  ident { identStart identChar* }\r\n  Symbol { ident }\r\n\r\n  keyword { \":\" \":\"? ident? } // the invalid token :: can also be considered as a keyword\r\n  Keyword { keyword }\r\n\r\n  Number {\r\n    (\"+\" | \"-\")? (std.digit+ (\".\" std.digit* \"M\"?)? | \".\" std.digit+) ((\"e\" | \"E\") (\"+\" | \"-\")? std.digit+ \"M\"?)? |\r\n    (\"+\" | \"-\")? std.digit+ (\"M\" | \"N\") |\r\n    (\"+\" | \"-\")? std.digit+ \"/\" std.digit+ |\r\n    (\"+\" | \"-\")? \"0x\" (std.digit | $[a-fA-F])+ |\r\n    \"0b\" $[01]+ |\r\n    \"0o\" $[0-7]+\r\n  }\r\n  @precedence { Number, qualifiedJavaIdent, readerTagIdent, Symbol }\r\n\r\n  StringContent {\r\n    (![\"] | \"\\\\\" _)+\r\n  }\r\n\r\n  unicodeChar { \"u\" $[0-9a-fA-F] $[0-9a-fA-F] $[0-9a-fA-F] $[0-9a-fA-F]}\r\n  octalChar { \"o\" $[0-3]? $[0-7] $[0-7]? }\r\n  specialChar { \"newline\" | \"space\" | \"tab\" | \"formfeed\" | \"backspace\" | \"return\" }\r\n  singleChar { ![\\n] }\r\n  Character { \"\\\\\" ( octalChar | unicodeChar |  singleChar | specialChar ) }\r\n\r\n}\r\n\r\nBoolean { @specialize<Symbol, \"true\" | \"false\"> }\r\nNil { @specialize<Symbol, \"nil\"> }\r\nDefLike[@dynamicPrecedence=1] { @extend<Symbol, \"def\" | \"defn\" | \"defn-\" | \"defmacro\" | \"definline\" | \"defonce\" | \"deftest\" | \"defcard\"> }\r\nNS[@dynamicPrecedence=2] { @extend<Symbol, \"ns\"> }\r\n\r\n@detectDelim\r\n",({"externalProp": nextjournal.clojure_mode.node.node_prop}));

//# sourceMappingURL=nextjournal.clojure_mode.live_grammar.js.map
