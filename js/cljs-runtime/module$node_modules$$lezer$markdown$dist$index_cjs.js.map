{
"version":3,
"file":"module$node_modules$$lezer$markdown$dist$index_cjs.js",
"lineCount":94,
"mappings":"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",
"sources":["node_modules/@lezer/markdown/dist/index.cjs"],
"sourcesContent":["shadow$provide[\"module$node_modules$$lezer$markdown$dist$index_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar common = require('@lezer/common');\nvar highlight = require('@lezer/highlight');\n\nclass CompositeBlock {\n    constructor(type, \n    // Used for indentation in list items, markup character in lists\n    value, from, hash, end, children, positions) {\n        this.type = type;\n        this.value = value;\n        this.from = from;\n        this.hash = hash;\n        this.end = end;\n        this.children = children;\n        this.positions = positions;\n        this.hashProp = [[common.NodeProp.contextHash, hash]];\n    }\n    static create(type, value, from, parentHash, end) {\n        let hash = (parentHash + (parentHash << 8) + type + (value << 4)) | 0;\n        return new CompositeBlock(type, value, from, hash, end, [], []);\n    }\n    addChild(child, pos) {\n        if (child.prop(common.NodeProp.contextHash) != this.hash)\n            child = new common.Tree(child.type, child.children, child.positions, child.length, this.hashProp);\n        this.children.push(child);\n        this.positions.push(pos);\n    }\n    toTree(nodeSet, end = this.end) {\n        let last = this.children.length - 1;\n        if (last >= 0)\n            end = Math.max(end, this.positions[last] + this.children[last].length + this.from);\n        let tree = new common.Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({\n            makeTree: (children, positions, length) => new common.Tree(common.NodeType.none, children, positions, length, this.hashProp)\n        });\n        return tree;\n    }\n}\nvar Type;\n(function (Type) {\n    Type[Type[\"Document\"] = 1] = \"Document\";\n    Type[Type[\"CodeBlock\"] = 2] = \"CodeBlock\";\n    Type[Type[\"FencedCode\"] = 3] = \"FencedCode\";\n    Type[Type[\"Blockquote\"] = 4] = \"Blockquote\";\n    Type[Type[\"HorizontalRule\"] = 5] = \"HorizontalRule\";\n    Type[Type[\"BulletList\"] = 6] = \"BulletList\";\n    Type[Type[\"OrderedList\"] = 7] = \"OrderedList\";\n    Type[Type[\"ListItem\"] = 8] = \"ListItem\";\n    Type[Type[\"ATXHeading1\"] = 9] = \"ATXHeading1\";\n    Type[Type[\"ATXHeading2\"] = 10] = \"ATXHeading2\";\n    Type[Type[\"ATXHeading3\"] = 11] = \"ATXHeading3\";\n    Type[Type[\"ATXHeading4\"] = 12] = \"ATXHeading4\";\n    Type[Type[\"ATXHeading5\"] = 13] = \"ATXHeading5\";\n    Type[Type[\"ATXHeading6\"] = 14] = \"ATXHeading6\";\n    Type[Type[\"SetextHeading1\"] = 15] = \"SetextHeading1\";\n    Type[Type[\"SetextHeading2\"] = 16] = \"SetextHeading2\";\n    Type[Type[\"HTMLBlock\"] = 17] = \"HTMLBlock\";\n    Type[Type[\"LinkReference\"] = 18] = \"LinkReference\";\n    Type[Type[\"Paragraph\"] = 19] = \"Paragraph\";\n    Type[Type[\"CommentBlock\"] = 20] = \"CommentBlock\";\n    Type[Type[\"ProcessingInstructionBlock\"] = 21] = \"ProcessingInstructionBlock\";\n    // Inline\n    Type[Type[\"Escape\"] = 22] = \"Escape\";\n    Type[Type[\"Entity\"] = 23] = \"Entity\";\n    Type[Type[\"HardBreak\"] = 24] = \"HardBreak\";\n    Type[Type[\"Emphasis\"] = 25] = \"Emphasis\";\n    Type[Type[\"StrongEmphasis\"] = 26] = \"StrongEmphasis\";\n    Type[Type[\"Link\"] = 27] = \"Link\";\n    Type[Type[\"Image\"] = 28] = \"Image\";\n    Type[Type[\"InlineCode\"] = 29] = \"InlineCode\";\n    Type[Type[\"HTMLTag\"] = 30] = \"HTMLTag\";\n    Type[Type[\"Comment\"] = 31] = \"Comment\";\n    Type[Type[\"ProcessingInstruction\"] = 32] = \"ProcessingInstruction\";\n    Type[Type[\"URL\"] = 33] = \"URL\";\n    // Smaller tokens\n    Type[Type[\"HeaderMark\"] = 34] = \"HeaderMark\";\n    Type[Type[\"QuoteMark\"] = 35] = \"QuoteMark\";\n    Type[Type[\"ListMark\"] = 36] = \"ListMark\";\n    Type[Type[\"LinkMark\"] = 37] = \"LinkMark\";\n    Type[Type[\"EmphasisMark\"] = 38] = \"EmphasisMark\";\n    Type[Type[\"CodeMark\"] = 39] = \"CodeMark\";\n    Type[Type[\"CodeText\"] = 40] = \"CodeText\";\n    Type[Type[\"CodeInfo\"] = 41] = \"CodeInfo\";\n    Type[Type[\"LinkTitle\"] = 42] = \"LinkTitle\";\n    Type[Type[\"LinkLabel\"] = 43] = \"LinkLabel\";\n})(Type || (Type = {}));\n/// Data structure used to accumulate a block's content during [leaf\n/// block parsing](#BlockParser.leaf).\nclass LeafBlock {\n    /// @internal\n    constructor(\n    /// The start position of the block.\n    start, \n    /// The block's text content.\n    content) {\n        this.start = start;\n        this.content = content;\n        /// @internal\n        this.marks = [];\n        /// The block parsers active for this block.\n        this.parsers = [];\n    }\n}\n/// Data structure used during block-level per-line parsing.\nclass Line {\n    constructor() {\n        /// The line's full text.\n        this.text = \"\";\n        /// The base indent provided by the composite contexts (that have\n        /// been handled so far).\n        this.baseIndent = 0;\n        /// The string position corresponding to the base indent.\n        this.basePos = 0;\n        /// The number of contexts handled @internal\n        this.depth = 0;\n        /// Any markers (i.e. block quote markers) parsed for the contexts. @internal\n        this.markers = [];\n        /// The position of the next non-whitespace character beyond any\n        /// list, blockquote, or other composite block markers.\n        this.pos = 0;\n        /// The column of the next non-whitespace character.\n        this.indent = 0;\n        /// The character code of the character after `pos`.\n        this.next = -1;\n    }\n    /// @internal\n    forward() {\n        if (this.basePos > this.pos)\n            this.forwardInner();\n    }\n    /// @internal\n    forwardInner() {\n        let newPos = this.skipSpace(this.basePos);\n        this.indent = this.countIndent(newPos, this.pos, this.indent);\n        this.pos = newPos;\n        this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);\n    }\n    /// Skip whitespace after the given position, return the position of\n    /// the next non-space character or the end of the line if there's\n    /// only space after `from`.\n    skipSpace(from) { return skipSpace(this.text, from); }\n    /// @internal\n    reset(text) {\n        this.text = text;\n        this.baseIndent = this.basePos = this.pos = this.indent = 0;\n        this.forwardInner();\n        this.depth = 1;\n        while (this.markers.length)\n            this.markers.pop();\n    }\n    /// Move the line's base position forward to the given position.\n    /// This should only be called by composite [block\n    /// parsers](#BlockParser.parse) or [markup skipping\n    /// functions](#NodeSpec.composite).\n    moveBase(to) {\n        this.basePos = to;\n        this.baseIndent = this.countIndent(to, this.pos, this.indent);\n    }\n    /// Move the line's base position forward to the given _column_.\n    moveBaseColumn(indent) {\n        this.baseIndent = indent;\n        this.basePos = this.findColumn(indent);\n    }\n    /// Store a composite-block-level marker. Should be called from\n    /// [markup skipping functions](#NodeSpec.composite) when they\n    /// consume any non-whitespace characters.\n    addMarker(elt) {\n        this.markers.push(elt);\n    }\n    /// Find the column position at `to`, optionally starting at a given\n    /// position and column.\n    countIndent(to, from = 0, indent = 0) {\n        for (let i = from; i < to; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return indent;\n    }\n    /// Find the position corresponding to the given column.\n    findColumn(goal) {\n        let i = 0;\n        for (let indent = 0; i < this.text.length && indent < goal; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return i;\n    }\n    /// @internal\n    scrub() {\n        if (!this.baseIndent)\n            return this.text;\n        let result = \"\";\n        for (let i = 0; i < this.basePos; i++)\n            result += \" \";\n        return result + this.text.slice(this.basePos);\n    }\n}\nfunction skipForList(bl, cx, line) {\n    if (line.pos == line.text.length ||\n        (bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent))\n        return true;\n    if (line.indent >= line.baseIndent + 4)\n        return false;\n    let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);\n    return size > 0 &&\n        (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) &&\n        line.text.charCodeAt(line.pos + size - 1) == bl.value;\n}\nconst DefaultSkipMarkup = {\n    [Type.Blockquote](bl, cx, line) {\n        if (line.next != 62 /* '>' */)\n            return false;\n        line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));\n        line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));\n        bl.end = cx.lineStart + line.text.length;\n        return true;\n    },\n    [Type.ListItem](bl, _cx, line) {\n        if (line.indent < line.baseIndent + bl.value && line.next > -1)\n            return false;\n        line.moveBaseColumn(line.baseIndent + bl.value);\n        return true;\n    },\n    [Type.OrderedList]: skipForList,\n    [Type.BulletList]: skipForList,\n    [Type.Document]() { return true; }\n};\nfunction space(ch) { return ch == 32 || ch == 9 || ch == 10 || ch == 13; }\nfunction skipSpace(line, i = 0) {\n    while (i < line.length && space(line.charCodeAt(i)))\n        i++;\n    return i;\n}\nfunction skipSpaceBack(line, i, to) {\n    while (i > to && space(line.charCodeAt(i - 1)))\n        i--;\n    return i;\n}\nfunction isFencedCode(line) {\n    if (line.next != 96 && line.next != 126 /* '`~' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    if (pos < line.pos + 3)\n        return -1;\n    if (line.next == 96)\n        for (let i = pos; i < line.text.length; i++)\n            if (line.text.charCodeAt(i) == 96)\n                return -1;\n    return pos;\n}\nfunction isBlockquote(line) {\n    return line.next != 62 /* '>' */ ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;\n}\nfunction isHorizontalRule(line, cx, breaking) {\n    if (line.next != 42 && line.next != 45 && line.next != 95 /* '_-*' */)\n        return -1;\n    let count = 1;\n    for (let pos = line.pos + 1; pos < line.text.length; pos++) {\n        let ch = line.text.charCodeAt(pos);\n        if (ch == line.next)\n            count++;\n        else if (!space(ch))\n            return -1;\n    }\n    // Setext headers take precedence\n    if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length)\n        return -1;\n    return count < 3 ? -1 : 1;\n}\nfunction inList(cx, type) {\n    for (let i = cx.stack.length - 1; i >= 0; i--)\n        if (cx.stack[i].type == type)\n            return true;\n    return false;\n}\nfunction isBulletList(line, cx, breaking) {\n    return (line.next == 45 || line.next == 43 || line.next == 42 /* '-+*' */) &&\n        (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) &&\n        (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;\n}\nfunction isOrderedList(line, cx, breaking) {\n    let pos = line.pos, next = line.next;\n    for (;;) {\n        if (next >= 48 && next <= 57 /* '0-9' */)\n            pos++;\n        else\n            break;\n        if (pos == line.text.length)\n            return -1;\n        next = line.text.charCodeAt(pos);\n    }\n    if (pos == line.pos || pos > line.pos + 9 ||\n        (next != 46 && next != 41 /* '.)' */) ||\n        (pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1))) ||\n        breaking && !inList(cx, Type.OrderedList) &&\n            (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49 /* '1' */))\n        return -1;\n    return pos + 1 - line.pos;\n}\nfunction isAtxHeading(line) {\n    if (line.next != 35 /* '#' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == 35)\n        pos++;\n    if (pos < line.text.length && line.text.charCodeAt(pos) != 32)\n        return -1;\n    let size = pos - line.pos;\n    return size > 6 ? -1 : size;\n}\nfunction isSetextUnderline(line) {\n    if (line.next != 45 && line.next != 61 /* '-=' */ || line.indent >= line.baseIndent + 4)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    let end = pos;\n    while (pos < line.text.length && space(line.text.charCodeAt(pos)))\n        pos++;\n    return pos == line.text.length ? end : -1;\n}\nconst EmptyLine = /^[ \\t]*$/, CommentEnd = /--\u003e/, ProcessingEnd = /\\?>/;\nconst HTMLBlockStyle = [\n    [/^<(?:script|pre|style)(?:\\s|>|$)/i, /<\\/(?:script|pre|style)>/i],\n    [/^\\s*\u003c!--/, CommentEnd],\n    [/^\\s*<\\?/, ProcessingEnd],\n    [/^\\s*<![A-Z]/, />/],\n    [/^\\s*<!\\[CDATA\\[/, /\\]\\]>/],\n    [/^\\s*<\\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|\\/?>|$)/i, EmptyLine],\n    [/^\\s*(?:<\\/[a-z][\\w-]*\\s*>|<[a-z][\\w-]*(\\s+[a-z:_][\\w-.]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*>)\\s*$/i, EmptyLine]\n];\nfunction isHTMLBlock(line, _cx, breaking) {\n    if (line.next != 60 /* '<' */)\n        return -1;\n    let rest = line.text.slice(line.pos);\n    for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)\n        if (HTMLBlockStyle[i][0].test(rest))\n            return i;\n    return -1;\n}\nfunction getListIndent(line, pos) {\n    let indentAfter = line.countIndent(pos, line.pos, line.indent);\n    let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);\n    return indented >= indentAfter + 5 ? indentAfter + 1 : indented;\n}\nfunction addCodeText(marks, from, to) {\n    let last = marks.length - 1;\n    if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText)\n        marks[last].to = to;\n    else\n        marks.push(elt(Type.CodeText, from, to));\n}\n// Rules for parsing blocks. A return value of false means the rule\n// doesn't apply here, true means it does. When true is returned and\n// `p.line` has been updated, the rule is assumed to have consumed a\n// leaf block. Otherwise, it is assumed to have opened a context.\nconst DefaultBlockParsers = {\n    LinkReference: undefined,\n    IndentedCode(cx, line) {\n        let base = line.baseIndent + 4;\n        if (line.indent < base)\n            return false;\n        let start = line.findColumn(base);\n        let from = cx.lineStart + start, to = cx.lineStart + line.text.length;\n        let marks = [], pendingMarks = [];\n        addCodeText(marks, from, to);\n        while (cx.nextLine() && line.depth >= cx.stack.length) {\n            if (line.pos == line.text.length) { // Empty\n                addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    pendingMarks.push(m);\n            }\n            else if (line.indent < base) {\n                break;\n            }\n            else {\n                if (pendingMarks.length) {\n                    for (let m of pendingMarks) {\n                        if (m.type == Type.CodeText)\n                            addCodeText(marks, m.from, m.to);\n                        else\n                            marks.push(m);\n                    }\n                    pendingMarks = [];\n                }\n                addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                to = cx.lineStart + line.text.length;\n                let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);\n                if (codeStart < to)\n                    addCodeText(marks, codeStart, to);\n            }\n        }\n        if (pendingMarks.length) {\n            pendingMarks = pendingMarks.filter(m => m.type != Type.CodeText);\n            if (pendingMarks.length)\n                line.markers = pendingMarks.concat(line.markers);\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);\n        return true;\n    },\n    FencedCode(cx, line) {\n        let fenceEnd = isFencedCode(line);\n        if (fenceEnd < 0)\n            return false;\n        let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;\n        let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);\n        let marks = [elt(Type.CodeMark, from, from + len)];\n        if (infoFrom < infoTo)\n            marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));\n        for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {\n            let i = line.pos;\n            if (line.indent - line.baseIndent < 4)\n                while (i < line.text.length && line.text.charCodeAt(i) == ch)\n                    i++;\n            if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {\n                for (let m of line.markers)\n                    marks.push(m);\n                marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));\n                cx.nextLine();\n                break;\n            }\n            else {\n                if (!first)\n                    addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;\n                if (textStart < textEnd)\n                    addCodeText(marks, textStart, textEnd);\n            }\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from)\n            .finish(Type.FencedCode, cx.prevLineEnd() - from), from);\n        return true;\n    },\n    Blockquote(cx, line) {\n        let size = isBlockquote(line);\n        if (size < 0)\n            return false;\n        cx.startContext(Type.Blockquote, line.pos);\n        cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);\n        line.moveBase(line.pos + size);\n        return null;\n    },\n    HorizontalRule(cx, line) {\n        if (isHorizontalRule(line, cx, false) < 0)\n            return false;\n        let from = cx.lineStart + line.pos;\n        cx.nextLine();\n        cx.addNode(Type.HorizontalRule, from);\n        return true;\n    },\n    BulletList(cx, line) {\n        let size = isBulletList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.BulletList)\n            cx.startContext(Type.BulletList, line.basePos, line.next);\n        let newBase = getListIndent(line, line.pos + 1);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    OrderedList(cx, line) {\n        let size = isOrderedList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.OrderedList)\n            cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));\n        let newBase = getListIndent(line, line.pos + size);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    ATXHeading(cx, line) {\n        let size = isAtxHeading(line);\n        if (size < 0)\n            return false;\n        let off = line.pos, from = cx.lineStart + off;\n        let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;\n        while (after > off && line.text.charCodeAt(after - 1) == line.next)\n            after--;\n        if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))\n            after = line.text.length;\n        let buf = cx.buffer\n            .write(Type.HeaderMark, 0, size)\n            .writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);\n        if (after < line.text.length)\n            buf.write(Type.HeaderMark, after - off, endOfSpace - off);\n        let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);\n        cx.nextLine();\n        cx.addNode(node, from);\n        return true;\n    },\n    HTMLBlock(cx, line) {\n        let type = isHTMLBlock(line, cx, false);\n        if (type < 0)\n            return false;\n        let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];\n        let marks = [], trailing = end != EmptyLine;\n        while (!end.test(line.text) && cx.nextLine()) {\n            if (line.depth < cx.stack.length) {\n                trailing = false;\n                break;\n            }\n            for (let m of line.markers)\n                marks.push(m);\n        }\n        if (trailing)\n            cx.nextLine();\n        let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;\n        let to = cx.prevLineEnd();\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);\n        return true;\n    },\n    SetextHeading: undefined // Specifies relative precedence for block-continue function\n};\n// This implements a state machine that incrementally parses link references. At each\n// next line, it looks ahead to see if the line continues the reference or not. If it\n// doesn't and a valid link is available ending before that line, it finishes that.\n// Similarly, on `finish` (when the leaf is terminated by external circumstances), it\n// creates a link reference if there's a valid reference up to the current point.\nclass LinkReferenceParser {\n    constructor(leaf) {\n        this.stage = 0 /* Start */;\n        this.elts = [];\n        this.pos = 0;\n        this.start = leaf.start;\n        this.advance(leaf.content);\n    }\n    nextLine(cx, line, leaf) {\n        if (this.stage == -1 /* Failed */)\n            return false;\n        let content = leaf.content + \"\\n\" + line.scrub();\n        let finish = this.advance(content);\n        if (finish > -1 && finish < content.length)\n            return this.complete(cx, leaf, finish);\n        return false;\n    }\n    finish(cx, leaf) {\n        if ((this.stage == 2 /* Link */ || this.stage == 3 /* Title */) && skipSpace(leaf.content, this.pos) == leaf.content.length)\n            return this.complete(cx, leaf, leaf.content.length);\n        return false;\n    }\n    complete(cx, leaf, len) {\n        cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));\n        return true;\n    }\n    nextStage(elt) {\n        if (elt) {\n            this.pos = elt.to - this.start;\n            this.elts.push(elt);\n            this.stage++;\n            return true;\n        }\n        if (elt === false)\n            this.stage = -1 /* Failed */;\n        return false;\n    }\n    advance(content) {\n        for (;;) {\n            if (this.stage == -1 /* Failed */) {\n                return -1;\n            }\n            else if (this.stage == 0 /* Start */) {\n                if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true)))\n                    return -1;\n                if (content.charCodeAt(this.pos) != 58 /* ':' */)\n                    return this.stage = -1 /* Failed */;\n                this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));\n                this.pos++;\n            }\n            else if (this.stage == 1 /* Label */) {\n                if (!this.nextStage(parseURL(content, skipSpace(content, this.pos), this.start)))\n                    return -1;\n            }\n            else if (this.stage == 2 /* Link */) {\n                let skip = skipSpace(content, this.pos), end = 0;\n                if (skip > this.pos) {\n                    let title = parseLinkTitle(content, skip, this.start);\n                    if (title) {\n                        let titleEnd = lineEnd(content, title.to - this.start);\n                        if (titleEnd > 0) {\n                            this.nextStage(title);\n                            end = titleEnd;\n                        }\n                    }\n                }\n                if (!end)\n                    end = lineEnd(content, this.pos);\n                return end > 0 && end < content.length ? end : -1;\n            }\n            else { // RefStage.Title\n                return lineEnd(content, this.pos);\n            }\n        }\n    }\n}\nfunction lineEnd(text, pos) {\n    for (; pos < text.length; pos++) {\n        let next = text.charCodeAt(pos);\n        if (next == 10)\n            break;\n        if (!space(next))\n            return -1;\n    }\n    return pos;\n}\nclass SetextHeadingParser {\n    nextLine(cx, line, leaf) {\n        let underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);\n        let next = line.next;\n        if (underline < 0)\n            return false;\n        let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);\n        cx.nextLine();\n        cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [\n            ...cx.parser.parseInline(leaf.content, leaf.start),\n            underlineMark\n        ]));\n        return true;\n    }\n    finish() {\n        return false;\n    }\n}\nconst DefaultLeafBlocks = {\n    LinkReference(_, leaf) { return leaf.content.charCodeAt(0) == 91 /* '[' */ ? new LinkReferenceParser(leaf) : null; },\n    SetextHeading() { return new SetextHeadingParser; }\n};\nconst DefaultEndLeaf = [\n    (_, line) => isAtxHeading(line) >= 0,\n    (_, line) => isFencedCode(line) >= 0,\n    (_, line) => isBlockquote(line) >= 0,\n    (p, line) => isBulletList(line, p, true) >= 0,\n    (p, line) => isOrderedList(line, p, true) >= 0,\n    (p, line) => isHorizontalRule(line, p, true) >= 0,\n    (p, line) => isHTMLBlock(line, p, true) >= 0\n];\nconst scanLineResult = { text: \"\", end: 0 };\n/// Block-level parsing functions get access to this context object.\nclass BlockContext {\n    /// @internal\n    constructor(\n    /// The parser configuration used.\n    parser, \n    /// @internal\n    input, fragments, \n    /// @internal\n    ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.line = new Line();\n        this.atEnd = false;\n        /// @internal\n        this.dontInject = new Set;\n        this.stoppedAt = null;\n        /// The range index that absoluteLineStart points into @internal\n        this.rangeI = 0;\n        this.to = ranges[ranges.length - 1].to;\n        this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;\n        this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);\n        this.stack = [this.block];\n        this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;\n        this.readLine();\n    }\n    get parsedPos() {\n        return this.absoluteLineStart;\n    }\n    advance() {\n        if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)\n            return this.finish();\n        let { line } = this;\n        for (;;) {\n            while (line.depth < this.stack.length)\n                this.finishContext();\n            for (let mark of line.markers)\n                this.addNode(mark.type, mark.from, mark.to);\n            if (line.pos < line.text.length)\n                break;\n            // Empty line\n            if (!this.nextLine())\n                return this.finish();\n        }\n        if (this.fragments && this.reuseFragment(line.basePos))\n            return null;\n        start: for (;;) {\n            for (let type of this.parser.blockParsers)\n                if (type) {\n                    let result = type(this, line);\n                    if (result != false) {\n                        if (result == true)\n                            return null;\n                        line.forward();\n                        continue start;\n                    }\n                }\n            break;\n        }\n        let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));\n        for (let parse of this.parser.leafBlockParsers)\n            if (parse) {\n                let parser = parse(this, leaf);\n                if (parser)\n                    leaf.parsers.push(parser);\n            }\n        lines: while (this.nextLine()) {\n            if (line.pos == line.text.length)\n                break;\n            if (line.indent < line.baseIndent + 4) {\n                for (let stop of this.parser.endLeafBlock)\n                    if (stop(this, line, leaf))\n                        break lines;\n            }\n            for (let parser of leaf.parsers)\n                if (parser.nextLine(this, line, leaf))\n                    return null;\n            leaf.content += \"\\n\" + line.scrub();\n            for (let m of line.markers)\n                leaf.marks.push(m);\n        }\n        this.finishLeaf(leaf);\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    reuseFragment(start) {\n        if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) ||\n            !this.fragments.matches(this.block.hash))\n            return false;\n        let taken = this.fragments.takeNodes(this);\n        if (!taken)\n            return false;\n        let withoutGaps = taken, end = this.absoluteLineStart + taken;\n        for (let i = 1; i < this.ranges.length; i++) {\n            let gapFrom = this.ranges[i - 1].to, gapTo = this.ranges[i].from;\n            if (gapFrom >= this.lineStart && gapTo < end)\n                withoutGaps -= gapTo - gapFrom;\n        }\n        this.lineStart += withoutGaps;\n        this.absoluteLineStart += taken;\n        this.moveRangeI();\n        if (this.absoluteLineStart < this.to) {\n            this.lineStart++;\n            this.absoluteLineStart++;\n            this.readLine();\n        }\n        else {\n            this.atEnd = true;\n            this.readLine();\n        }\n        return true;\n    }\n    /// The number of parent blocks surrounding the current block.\n    get depth() {\n        return this.stack.length;\n    }\n    /// Get the type of the parent block at the given depth. When no\n    /// depth is passed, return the type of the innermost parent.\n    parentType(depth = this.depth - 1) {\n        return this.parser.nodeSet.types[this.stack[depth].type];\n    }\n    /// Move to the next input line. This should only be called by\n    /// (non-composite) [block parsers](#BlockParser.parse) that consume\n    /// the line directly, or leaf block parser\n    /// [`nextLine`](#LeafBlockParser.nextLine) methods when they\n    /// consume the current line (and return true).\n    nextLine() {\n        this.lineStart += this.line.text.length;\n        if (this.absoluteLineEnd >= this.to) {\n            this.absoluteLineStart = this.absoluteLineEnd;\n            this.atEnd = true;\n            this.readLine();\n            return false;\n        }\n        else {\n            this.lineStart++;\n            this.absoluteLineStart = this.absoluteLineEnd + 1;\n            this.moveRangeI();\n            this.readLine();\n            return true;\n        }\n    }\n    moveRangeI() {\n        while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {\n            this.rangeI++;\n            this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);\n        }\n    }\n    /// @internal\n    scanLine(start) {\n        let r = scanLineResult;\n        r.end = start;\n        if (start >= this.to) {\n            r.text = \"\";\n        }\n        else {\n            r.text = this.lineChunkAt(start);\n            r.end += r.text.length;\n            if (this.ranges.length > 1) {\n                let textOffset = this.absoluteLineStart, rangeI = this.rangeI;\n                while (this.ranges[rangeI].to < r.end) {\n                    rangeI++;\n                    let nextFrom = this.ranges[rangeI].from;\n                    let after = this.lineChunkAt(nextFrom);\n                    r.end = nextFrom + after.length;\n                    r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;\n                    textOffset = r.end - r.text.length;\n                }\n            }\n        }\n        return r;\n    }\n    /// @internal\n    readLine() {\n        let { line } = this, { text, end } = this.scanLine(this.absoluteLineStart);\n        this.absoluteLineEnd = end;\n        line.reset(text);\n        for (; line.depth < this.stack.length; line.depth++) {\n            let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];\n            if (!handler)\n                throw new Error(\"Unhandled block context \" + Type[cx.type]);\n            if (!handler(cx, this, line))\n                break;\n            line.forward();\n        }\n    }\n    lineChunkAt(pos) {\n        let next = this.input.chunk(pos), text;\n        if (!this.input.lineChunks) {\n            let eol = next.indexOf(\"\\n\");\n            text = eol < 0 ? next : next.slice(0, eol);\n        }\n        else {\n            text = next == \"\\n\" ? \"\" : next;\n        }\n        return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;\n    }\n    /// The end position of the previous line.\n    prevLineEnd() { return this.atEnd ? this.lineStart : this.lineStart - 1; }\n    /// @internal\n    startContext(type, start, value = 0) {\n        this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);\n        this.stack.push(this.block);\n    }\n    /// Start a composite block. Should only be called from [block\n    /// parser functions](#BlockParser.parse) that return null.\n    startComposite(type, start, value = 0) {\n        this.startContext(this.parser.getNodeType(type), start, value);\n    }\n    /// @internal\n    addNode(block, from, to) {\n        if (typeof block == \"number\")\n            block = new common.Tree(this.parser.nodeSet.types[block], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);\n        this.block.addChild(block, from - this.block.from);\n    }\n    /// Add a block element. Can be called by [block\n    /// parsers](#BlockParser.parse).\n    addElement(elt) {\n        this.block.addChild(elt.toTree(this.parser.nodeSet), elt.from - this.block.from);\n    }\n    /// Add a block element from a [leaf parser](#LeafBlockParser). This\n    /// makes sure any extra composite block markup (such as blockquote\n    /// markers) inside the block are also added to the syntax tree.\n    addLeafElement(leaf, elt) {\n        this.addNode(this.buffer\n            .writeElements(injectMarks(elt.children, leaf.marks), -elt.from)\n            .finish(elt.type, elt.to - elt.from), elt.from);\n    }\n    /// @internal\n    finishContext() {\n        let cx = this.stack.pop();\n        let top = this.stack[this.stack.length - 1];\n        top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);\n        this.block = top;\n    }\n    finish() {\n        while (this.stack.length > 1)\n            this.finishContext();\n        return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));\n    }\n    addGaps(tree) {\n        return this.ranges.length > 1 ? injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.dontInject) : tree;\n    }\n    /// @internal\n    finishLeaf(leaf) {\n        for (let parser of leaf.parsers)\n            if (parser.finish(this, leaf))\n                return;\n        let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);\n        this.addNode(this.buffer\n            .writeElements(inline, -leaf.start)\n            .finish(Type.Paragraph, leaf.content.length), leaf.start);\n    }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n    /// @internal\n    get buffer() { return new Buffer(this.parser.nodeSet); }\n}\nfunction injectGaps(ranges, rangeI, tree, offset, dont) {\n    if (dont.has(tree.tree))\n        return tree.tree;\n    let rangeEnd = ranges[rangeI].to;\n    let children = [], positions = [], start = tree.from + offset;\n    function movePastNext(upto, inclusive) {\n        while (inclusive ? upto >= rangeEnd : upto > rangeEnd) {\n            let size = ranges[rangeI + 1].from - rangeEnd;\n            offset += size;\n            upto += size;\n            rangeI++;\n            rangeEnd = ranges[rangeI].to;\n        }\n    }\n    for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {\n        movePastNext(ch.from + offset, true);\n        let from = ch.from + offset, node;\n        if (ch.to + offset > rangeEnd) {\n            node = injectGaps(ranges, rangeI, ch, offset, dont);\n            movePastNext(ch.to + offset, false);\n        }\n        else {\n            node = ch.toTree();\n        }\n        children.push(node);\n        positions.push(from - start);\n    }\n    movePastNext(tree.to + offset, false);\n    return new common.Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);\n}\n/// A Markdown parser configuration.\nclass MarkdownParser extends common.Parser {\n    /// @internal\n    constructor(\n    /// The parser's syntax [node\n    /// types](https://lezer.codemirror.net/docs/ref/#common.NodeSet).\n    nodeSet, \n    /// @internal\n    blockParsers, \n    /// @internal\n    leafBlockParsers, \n    /// @internal\n    blockNames, \n    /// @internal\n    endLeafBlock, \n    /// @internal\n    skipContextMarkup, \n    /// @internal\n    inlineParsers, \n    /// @internal\n    inlineNames, \n    /// @internal\n    wrappers) {\n        super();\n        this.nodeSet = nodeSet;\n        this.blockParsers = blockParsers;\n        this.leafBlockParsers = leafBlockParsers;\n        this.blockNames = blockNames;\n        this.endLeafBlock = endLeafBlock;\n        this.skipContextMarkup = skipContextMarkup;\n        this.inlineParsers = inlineParsers;\n        this.inlineNames = inlineNames;\n        this.wrappers = wrappers;\n        /// @internal\n        this.nodeTypes = Object.create(null);\n        for (let t of nodeSet.types)\n            this.nodeTypes[t.name] = t.id;\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new BlockContext(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /// Reconfigure the parser.\n    configure(spec) {\n        let config = resolveConfig(spec);\n        if (!config)\n            return this;\n        let { nodeSet, skipContextMarkup } = this;\n        let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;\n        if (nonEmpty(config.defineNodes)) {\n            skipContextMarkup = Object.assign({}, skipContextMarkup);\n            let nodeTypes = nodeSet.types.slice(), styles;\n            for (let s of config.defineNodes) {\n                let { name, block, composite, style } = typeof s == \"string\" ? { name: s } : s;\n                if (nodeTypes.some(t => t.name == name))\n                    continue;\n                if (composite)\n                    skipContextMarkup[nodeTypes.length] =\n                        (bl, cx, line) => composite(cx, line, bl.value);\n                let id = nodeTypes.length;\n                let group = composite ? [\"Block\", \"BlockContext\"] : !block ? undefined\n                    : id >= Type.ATXHeading1 && id <= Type.SetextHeading2 ? [\"Block\", \"LeafBlock\", \"Heading\"] : [\"Block\", \"LeafBlock\"];\n                nodeTypes.push(common.NodeType.define({\n                    id,\n                    name,\n                    props: group && [[common.NodeProp.group, group]]\n                }));\n                if (style) {\n                    if (!styles)\n                        styles = {};\n                    if (Array.isArray(style) || style instanceof highlight.Tag)\n                        styles[name] = style;\n                    else\n                        Object.assign(styles, style);\n                }\n            }\n            nodeSet = new common.NodeSet(nodeTypes);\n            if (styles)\n                nodeSet = nodeSet.extend(highlight.styleTags(styles));\n        }\n        if (nonEmpty(config.props))\n            nodeSet = nodeSet.extend(...config.props);\n        if (nonEmpty(config.remove)) {\n            for (let rm of config.remove) {\n                let block = this.blockNames.indexOf(rm), inline = this.inlineNames.indexOf(rm);\n                if (block > -1)\n                    blockParsers[block] = leafBlockParsers[block] = undefined;\n                if (inline > -1)\n                    inlineParsers[inline] = undefined;\n            }\n        }\n        if (nonEmpty(config.parseBlock)) {\n            for (let spec of config.parseBlock) {\n                let found = blockNames.indexOf(spec.name);\n                if (found > -1) {\n                    blockParsers[found] = spec.parse;\n                    leafBlockParsers[found] = spec.leaf;\n                }\n                else {\n                    let pos = spec.before ? findName(blockNames, spec.before)\n                        : spec.after ? findName(blockNames, spec.after) + 1 : blockNames.length - 1;\n                    blockParsers.splice(pos, 0, spec.parse);\n                    leafBlockParsers.splice(pos, 0, spec.leaf);\n                    blockNames.splice(pos, 0, spec.name);\n                }\n                if (spec.endLeaf)\n                    endLeafBlock.push(spec.endLeaf);\n            }\n        }\n        if (nonEmpty(config.parseInline)) {\n            for (let spec of config.parseInline) {\n                let found = inlineNames.indexOf(spec.name);\n                if (found > -1) {\n                    inlineParsers[found] = spec.parse;\n                }\n                else {\n                    let pos = spec.before ? findName(inlineNames, spec.before)\n                        : spec.after ? findName(inlineNames, spec.after) + 1 : inlineNames.length - 1;\n                    inlineParsers.splice(pos, 0, spec.parse);\n                    inlineNames.splice(pos, 0, spec.name);\n                }\n            }\n        }\n        if (config.wrap)\n            wrappers = wrappers.concat(config.wrap);\n        return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);\n    }\n    /// @internal\n    getNodeType(name) {\n        let found = this.nodeTypes[name];\n        if (found == null)\n            throw new RangeError(`Unknown node type '${name}'`);\n        return found;\n    }\n    /// Parse the given piece of inline text at the given offset,\n    /// returning an array of [`Element`](#Element) objects representing\n    /// the inline content.\n    parseInline(text, offset) {\n        let cx = new InlineContext(this, text, offset);\n        outer: for (let pos = offset; pos < cx.end;) {\n            let next = cx.char(pos);\n            for (let token of this.inlineParsers)\n                if (token) {\n                    let result = token(cx, next, pos);\n                    if (result >= 0) {\n                        pos = result;\n                        continue outer;\n                    }\n                }\n            pos++;\n        }\n        return cx.resolveMarkers(0);\n    }\n}\nfunction nonEmpty(a) {\n    return a != null && a.length > 0;\n}\nfunction resolveConfig(spec) {\n    if (!Array.isArray(spec))\n        return spec;\n    if (spec.length == 0)\n        return null;\n    let conf = resolveConfig(spec[0]);\n    if (spec.length == 1)\n        return conf;\n    let rest = resolveConfig(spec.slice(1));\n    if (!rest || !conf)\n        return conf || rest;\n    let conc = (a, b) => (a || none).concat(b || none);\n    let wrapA = conf.wrap, wrapB = rest.wrap;\n    return {\n        props: conc(conf.props, rest.props),\n        defineNodes: conc(conf.defineNodes, rest.defineNodes),\n        parseBlock: conc(conf.parseBlock, rest.parseBlock),\n        parseInline: conc(conf.parseInline, rest.parseInline),\n        remove: conc(conf.remove, rest.remove),\n        wrap: !wrapA ? wrapB : !wrapB ? wrapA :\n            (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)\n    };\n}\nfunction findName(names, name) {\n    let found = names.indexOf(name);\n    if (found < 0)\n        throw new RangeError(`Position specified relative to unknown parser ${name}`);\n    return found;\n}\nlet nodeTypes = [common.NodeType.none];\nfor (let i = 1, name; name = Type[i]; i++) {\n    nodeTypes[i] = common.NodeType.define({\n        id: i,\n        name,\n        props: i >= Type.Escape ? [] : [[common.NodeProp.group, i in DefaultSkipMarkup ? [\"Block\", \"BlockContext\"] : [\"Block\", \"LeafBlock\"]]]\n    });\n}\nconst none = [];\nclass Buffer {\n    constructor(nodeSet) {\n        this.nodeSet = nodeSet;\n        this.content = [];\n        this.nodes = [];\n    }\n    write(type, from, to, children = 0) {\n        this.content.push(type, from, to, 4 + children * 4);\n        return this;\n    }\n    writeElements(elts, offset = 0) {\n        for (let e of elts)\n            e.writeTo(this, offset);\n        return this;\n    }\n    finish(type, length) {\n        return common.Tree.build({\n            buffer: this.content,\n            nodeSet: this.nodeSet,\n            reused: this.nodes,\n            topID: type,\n            length\n        });\n    }\n}\n/// Elements are used to compose syntax nodes during parsing.\nclass Element {\n    /// @internal\n    constructor(\n    /// The node's\n    /// [id](https://lezer.codemirror.net/docs/ref/#common.NodeType.id).\n    type, \n    /// The start of the node, as an offset from the start of the document.\n    from, \n    /// The end of the node.\n    to, \n    /// The node's child nodes @internal\n    children = none) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.children = children;\n    }\n    /// @internal\n    writeTo(buf, offset) {\n        let startOff = buf.content.length;\n        buf.writeElements(this.children, offset);\n        buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);\n    }\n    /// @internal\n    toTree(nodeSet) {\n        return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);\n    }\n}\nclass TreeElement {\n    constructor(tree, from) {\n        this.tree = tree;\n        this.from = from;\n    }\n    get to() { return this.from + this.tree.length; }\n    get type() { return this.tree.type.id; }\n    get children() { return none; }\n    writeTo(buf, offset) {\n        buf.nodes.push(this.tree);\n        buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);\n    }\n    toTree() { return this.tree; }\n}\nfunction elt(type, from, to, children) {\n    return new Element(type, from, to, children);\n}\nconst EmphasisUnderscore = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst EmphasisAsterisk = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst LinkStart = {}, ImageStart = {};\nclass InlineDelimiter {\n    constructor(type, from, to, side) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.side = side;\n    }\n}\nconst Escapable = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nlet Punctuation = /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~\\xA1\\u2010-\\u2027]/;\ntry {\n    Punctuation = new RegExp(\"[\\\\p{Pc}|\\\\p{Pd}|\\\\p{Pe}|\\\\p{Pf}|\\\\p{Pi}|\\\\p{Po}|\\\\p{Ps}]\", \"u\");\n}\ncatch (_) { }\nconst DefaultInline = {\n    Escape(cx, next, start) {\n        if (next != 92 /* '\\\\' */ || start == cx.end - 1)\n            return -1;\n        let escaped = cx.char(start + 1);\n        for (let i = 0; i < Escapable.length; i++)\n            if (Escapable.charCodeAt(i) == escaped)\n                return cx.append(elt(Type.Escape, start, start + 2));\n        return -1;\n    },\n    Entity(cx, next, start) {\n        if (next != 38 /* '&' */)\n            return -1;\n        let m = /^(?:#\\d+|#x[a-f\\d]+|\\w+);/i.exec(cx.slice(start + 1, start + 31));\n        return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;\n    },\n    InlineCode(cx, next, start) {\n        if (next != 96 /* '`' */ || start && cx.char(start - 1) == 96)\n            return -1;\n        let pos = start + 1;\n        while (pos < cx.end && cx.char(pos) == 96)\n            pos++;\n        let size = pos - start, curSize = 0;\n        for (; pos < cx.end; pos++) {\n            if (cx.char(pos) == 96) {\n                curSize++;\n                if (curSize == size && cx.char(pos + 1) != 96)\n                    return cx.append(elt(Type.InlineCode, start, pos + 1, [\n                        elt(Type.CodeMark, start, start + size),\n                        elt(Type.CodeMark, pos + 1 - size, pos + 1)\n                    ]));\n            }\n            else {\n                curSize = 0;\n            }\n        }\n        return -1;\n    },\n    HTMLTag(cx, next, start) {\n        if (next != 60 /* '<' */ || start == cx.end - 1)\n            return -1;\n        let after = cx.slice(start + 1, cx.end);\n        let url = /^(?:[a-z][-\\w+.]+:[^\\s>]+|[a-z\\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?(?:\\.[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?)*)>/i.exec(after);\n        if (url)\n            return cx.append(elt(Type.URL, start, start + 1 + url[0].length));\n        let comment = /^!--[^>](?:-[^-]|[^-])*?--\u003e/i.exec(after);\n        if (comment)\n            return cx.append(elt(Type.Comment, start, start + 1 + comment[0].length));\n        let procInst = /^\\?[^]*?\\?>/.exec(after);\n        if (procInst)\n            return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));\n        let m = /^(?:![A-Z][^]*?>|!\\[CDATA\\[[^]*?\\]\\]>|\\/\\s*[a-zA-Z][\\w-]*\\s*>|\\s*[a-zA-Z][\\w-]*(\\s+[a-zA-Z:_][\\w-.:]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*(\\/\\s*)?>)/.exec(after);\n        if (!m)\n            return -1;\n        return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));\n    },\n    Emphasis(cx, next, start) {\n        if (next != 95 && next != 42)\n            return -1;\n        let pos = start + 1;\n        while (cx.char(pos) == next)\n            pos++;\n        let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);\n        let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n        let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n        let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);\n        let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);\n        let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);\n        let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);\n        return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 /* Open */ : 0) | (canClose ? 2 /* Close */ : 0)));\n    },\n    HardBreak(cx, next, start) {\n        if (next == 92 /* '\\\\' */ && cx.char(start + 1) == 10 /* '\\n' */)\n            return cx.append(elt(Type.HardBreak, start, start + 2));\n        if (next == 32) {\n            let pos = start + 1;\n            while (cx.char(pos) == 32)\n                pos++;\n            if (cx.char(pos) == 10 && pos >= start + 2)\n                return cx.append(elt(Type.HardBreak, start, pos + 1));\n        }\n        return -1;\n    },\n    Link(cx, next, start) {\n        return next == 91 /* '[' */ ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1 /* Open */)) : -1;\n    },\n    Image(cx, next, start) {\n        return next == 33 /* '!' */ && cx.char(start + 1) == 91 /* '[' */\n            ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1 /* Open */)) : -1;\n    },\n    LinkEnd(cx, next, start) {\n        if (next != 93 /* ']' */)\n            return -1;\n        // Scanning back to the next link/image start marker\n        for (let i = cx.parts.length - 1; i >= 0; i--) {\n            let part = cx.parts[i];\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {\n                // If this one has been set invalid (because it would produce\n                // a nested link) or there's no valid link here ignore both.\n                if (!part.side || cx.skipSpace(part.to) == start && !/[(\\[]/.test(cx.slice(start + 1, start + 2))) {\n                    cx.parts[i] = null;\n                    return -1;\n                }\n                // Finish the content and replace the entire range in\n                // this.parts with the link/image node.\n                let content = cx.takeContent(i);\n                let link = cx.parts[i] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);\n                // Set any open-link markers before this link to invalid.\n                if (part.type == LinkStart)\n                    for (let j = 0; j < i; j++) {\n                        let p = cx.parts[j];\n                        if (p instanceof InlineDelimiter && p.type == LinkStart)\n                            p.side = 0;\n                    }\n                return link.to;\n            }\n        }\n        return -1;\n    }\n};\nfunction finishLink(cx, content, type, start, startPos) {\n    let { text } = cx, next = cx.char(startPos), endPos = startPos;\n    content.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));\n    content.push(elt(Type.LinkMark, startPos - 1, startPos));\n    if (next == 40 /* '(' */) {\n        let pos = cx.skipSpace(startPos + 1);\n        let dest = parseURL(text, pos - cx.offset, cx.offset), title;\n        if (dest) {\n            pos = cx.skipSpace(dest.to);\n            title = parseLinkTitle(text, pos - cx.offset, cx.offset);\n            if (title)\n                pos = cx.skipSpace(title.to);\n        }\n        if (cx.char(pos) == 41 /* ')' */) {\n            content.push(elt(Type.LinkMark, startPos, startPos + 1));\n            endPos = pos + 1;\n            if (dest)\n                content.push(dest);\n            if (title)\n                content.push(title);\n            content.push(elt(Type.LinkMark, pos, endPos));\n        }\n    }\n    else if (next == 91 /* '[' */) {\n        let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);\n        if (label) {\n            content.push(label);\n            endPos = label.to;\n        }\n    }\n    return elt(type, start, endPos, content);\n}\n// These return `null` when falling off the end of the input, `false`\n// when parsing fails otherwise (for use in the incremental link\n// reference parser).\nfunction parseURL(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next == 60 /* '<' */) {\n        for (let pos = start + 1; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (ch == 62 /* '>' */)\n                return elt(Type.URL, start + offset, pos + 1 + offset);\n            if (ch == 60 || ch == 10 /* '<\\n' */)\n                return false;\n        }\n        return null;\n    }\n    else {\n        let depth = 0, pos = start;\n        for (let escaped = false; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (space(ch)) {\n                break;\n            }\n            else if (escaped) {\n                escaped = false;\n            }\n            else if (ch == 40 /* '(' */) {\n                depth++;\n            }\n            else if (ch == 41 /* ')' */) {\n                if (!depth)\n                    break;\n                depth--;\n            }\n            else if (ch == 92 /* '\\\\' */) {\n                escaped = true;\n            }\n        }\n        return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;\n    }\n}\nfunction parseLinkTitle(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next != 39 && next != 34 && next != 40 /* '\"\\'(' */)\n        return false;\n    let end = next == 40 ? 41 : next;\n    for (let pos = start + 1, escaped = false; pos < text.length; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == end)\n            return elt(Type.LinkTitle, start + offset, pos + 1 + offset);\n        else if (ch == 92 /* '\\\\' */)\n            escaped = true;\n    }\n    return null;\n}\nfunction parseLinkLabel(text, start, offset, requireNonWS) {\n    for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == 93 /* ']' */)\n            return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);\n        else {\n            if (requireNonWS && !space(ch))\n                requireNonWS = false;\n            if (ch == 91 /* '[' */)\n                return false;\n            else if (ch == 92 /* '\\\\' */)\n                escaped = true;\n        }\n    }\n    return null;\n}\n/// Inline parsing functions get access to this context, and use it to\n/// read the content and emit syntax nodes.\nclass InlineContext {\n    /// @internal\n    constructor(\n    /// The parser that is being used.\n    parser, \n    /// The text of this inline section.\n    text, \n    /// The starting offset of the section in the document.\n    offset) {\n        this.parser = parser;\n        this.text = text;\n        this.offset = offset;\n        /// @internal\n        this.parts = [];\n    }\n    /// Get the character code at the given (document-relative)\n    /// position.\n    char(pos) { return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset); }\n    /// The position of the end of this inline section.\n    get end() { return this.offset + this.text.length; }\n    /// Get a substring of this inline section. Again uses\n    /// document-relative positions.\n    slice(from, to) { return this.text.slice(from - this.offset, to - this.offset); }\n    /// @internal\n    append(elt) {\n        this.parts.push(elt);\n        return elt.to;\n    }\n    /// Add a [delimiter](#DelimiterType) at this given position. `open`\n    /// and `close` indicate whether this delimiter is opening, closing,\n    /// or both. Returns the end of the delimiter, for convenient\n    /// returning from [parse functions](#InlineParser.parse).\n    addDelimiter(type, from, to, open, close) {\n        return this.append(new InlineDelimiter(type, from, to, (open ? 1 /* Open */ : 0) | (close ? 2 /* Close */ : 0)));\n    }\n    /// Add an inline element. Returns the end of the element.\n    addElement(elt) {\n        return this.append(elt);\n    }\n    /// @internal\n    resolveMarkers(from) {\n        for (let i = from; i < this.parts.length; i++) {\n            let close = this.parts[i];\n            if (!(close instanceof InlineDelimiter && close.type.resolve && (close.side & 2 /* Close */)))\n                continue;\n            let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;\n            let closeSize = close.to - close.from;\n            let open, j = i - 1;\n            for (; j >= from; j--) {\n                let part = this.parts[j];\n                if (!(part instanceof InlineDelimiter && (part.side & 1 /* Open */) && part.type == close.type) ||\n                    emp && ((close.side & 1 /* Open */) || (part.side & 2 /* Close */)) &&\n                        (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))\n                    continue;\n                open = part;\n                break;\n            }\n            if (!open)\n                continue;\n            let type = close.type.resolve, content = [];\n            let start = open.from, end = close.to;\n            if (emp) {\n                let size = Math.min(2, open.to - open.from, closeSize);\n                start = open.to - size;\n                end = close.from + size;\n                type = size == 1 ? \"Emphasis\" : \"StrongEmphasis\";\n            }\n            if (open.type.mark)\n                content.push(this.elt(open.type.mark, start, open.to));\n            for (let k = j + 1; k < i; k++) {\n                if (this.parts[k] instanceof Element)\n                    content.push(this.parts[k]);\n                this.parts[k] = null;\n            }\n            if (close.type.mark)\n                content.push(this.elt(close.type.mark, close.from, end));\n            let element = this.elt(type, start, end, content);\n            this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;\n            let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;\n            if (keep)\n                this.parts.splice(i, 0, element);\n            else\n                this.parts[i] = element;\n        }\n        let result = [];\n        for (let i = from; i < this.parts.length; i++) {\n            let part = this.parts[i];\n            if (part instanceof Element)\n                result.push(part);\n        }\n        return result;\n    }\n    /// Find an opening delimiter of the given type. Returns `null` if\n    /// no delimiter is found, or an index that can be passed to\n    /// [`takeContent`](#InlineContext.takeContent) otherwise.\n    findOpeningDelimiter(type) {\n        for (let i = this.parts.length - 1; i >= 0; i--) {\n            let part = this.parts[i];\n            if (part instanceof InlineDelimiter && part.type == type)\n                return i;\n        }\n        return null;\n    }\n    /// Remove all inline elements and delimiters starting from the\n    /// given index (which you should get from\n    /// [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),\n    /// resolve delimiters inside of them, and return them as an array\n    /// of elements.\n    takeContent(startIndex) {\n        let content = this.resolveMarkers(startIndex);\n        this.parts.length = startIndex;\n        return content;\n    }\n    /// Skip space after the given (document) position, returning either\n    /// the position of the next non-space character or the end of the\n    /// section.\n    skipSpace(from) { return skipSpace(this.text, from - this.offset) + this.offset; }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n}\nfunction injectMarks(elements, marks) {\n    if (!marks.length)\n        return elements;\n    if (!elements.length)\n        return marks;\n    let elts = elements.slice(), eI = 0;\n    for (let mark of marks) {\n        while (eI < elts.length && elts[eI].to < mark.to)\n            eI++;\n        if (eI < elts.length && elts[eI].from < mark.from) {\n            let e = elts[eI];\n            if (e instanceof Element)\n                elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));\n        }\n        else {\n            elts.splice(eI++, 0, mark);\n        }\n    }\n    return elts;\n}\n// These are blocks that can span blank lines, and should thus only be\n// reused if their next sibling is also being reused.\nconst NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];\nclass FragmentCursor {\n    constructor(fragments, input) {\n        this.fragments = fragments;\n        this.input = input;\n        // Index into fragment array\n        this.i = 0;\n        // Active fragment\n        this.fragment = null;\n        this.fragmentEnd = -1;\n        // Cursor into the current fragment, if any. When `moveTo` returns\n        // true, this points at the first block after `pos`.\n        this.cursor = null;\n        if (fragments.length)\n            this.fragment = fragments[this.i++];\n    }\n    nextFragment() {\n        this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;\n        this.cursor = null;\n        this.fragmentEnd = -1;\n    }\n    moveTo(pos, lineStart) {\n        while (this.fragment && this.fragment.to <= pos)\n            this.nextFragment();\n        if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))\n            return false;\n        if (this.fragmentEnd < 0) {\n            let end = this.fragment.to;\n            while (end > 0 && this.input.read(end - 1, end) != \"\\n\")\n                end--;\n            this.fragmentEnd = end ? end - 1 : 0;\n        }\n        let c = this.cursor;\n        if (!c) {\n            c = this.cursor = this.fragment.tree.cursor();\n            c.firstChild();\n        }\n        let rPos = pos + this.fragment.offset;\n        while (c.to <= rPos)\n            if (!c.parent())\n                return false;\n        for (;;) {\n            if (c.from >= rPos)\n                return this.fragment.from <= lineStart;\n            if (!c.childAfter(rPos))\n                return false;\n        }\n    }\n    matches(hash) {\n        let tree = this.cursor.tree;\n        return tree && tree.prop(common.NodeProp.contextHash) == hash;\n    }\n    takeNodes(cx) {\n        let cur = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);\n        let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;\n        let prevEnd = end, prevI = blockI;\n        for (;;) {\n            if (cur.to - off > fragEnd) {\n                if (cur.type.isAnonymous && cur.firstChild())\n                    continue;\n                break;\n            }\n            cx.dontInject.add(cur.tree);\n            cx.addNode(cur.tree, cur.from - off);\n            // Taken content must always end in a block, because incremental\n            // parsing happens on block boundaries. Never stop directly\n            // after an indented code block, since those can continue after\n            // any number of blank lines.\n            if (cur.type.is(\"Block\")) {\n                if (NotLast.indexOf(cur.type.id) < 0) {\n                    end = cur.to - off;\n                    blockI = cx.block.children.length;\n                }\n                else {\n                    end = prevEnd;\n                    blockI = prevI;\n                    prevEnd = cur.to - off;\n                    prevI = cx.block.children.length;\n                }\n            }\n            if (!cur.nextSibling())\n                break;\n        }\n        while (cx.block.children.length > blockI) {\n            cx.block.children.pop();\n            cx.block.positions.pop();\n        }\n        return end - start;\n    }\n}\nconst markdownHighlighting = highlight.styleTags({\n    \"Blockquote/...\": highlight.tags.quote,\n    HorizontalRule: highlight.tags.contentSeparator,\n    \"ATXHeading1/... SetextHeading1/...\": highlight.tags.heading1,\n    \"ATXHeading2/... SetextHeading2/...\": highlight.tags.heading2,\n    \"ATXHeading3/...\": highlight.tags.heading3,\n    \"ATXHeading4/...\": highlight.tags.heading4,\n    \"ATXHeading5/...\": highlight.tags.heading5,\n    \"ATXHeading6/...\": highlight.tags.heading6,\n    \"Comment CommentBlock\": highlight.tags.comment,\n    Escape: highlight.tags.escape,\n    Entity: highlight.tags.character,\n    \"Emphasis/...\": highlight.tags.emphasis,\n    \"StrongEmphasis/...\": highlight.tags.strong,\n    \"Link/... Image/...\": highlight.tags.link,\n    \"OrderedList/... BulletList/...\": highlight.tags.list,\n    \"BlockQuote/...\": highlight.tags.quote,\n    \"InlineCode CodeText\": highlight.tags.monospace,\n    URL: highlight.tags.url,\n    \"HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark\": highlight.tags.processingInstruction,\n    \"CodeInfo LinkLabel\": highlight.tags.labelName,\n    LinkTitle: highlight.tags.string,\n    Paragraph: highlight.tags.content\n});\n/// The default CommonMark parser.\nconst parser = new MarkdownParser(new common.NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map(n => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map(n => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map(n => DefaultInline[n]), Object.keys(DefaultInline), []);\n\nfunction leftOverSpace(node, from, to) {\n    let ranges = [];\n    for (let n = node.firstChild, pos = from;; n = n.nextSibling) {\n        let nextPos = n ? n.from : to;\n        if (nextPos > pos)\n            ranges.push({ from: pos, to: nextPos });\n        if (!n)\n            break;\n        pos = n.to;\n    }\n    return ranges;\n}\n/// Create a Markdown extension to enable nested parsing on code\n/// blocks and/or embedded HTML.\nfunction parseCode(config) {\n    let { codeParser, htmlParser } = config;\n    let wrap = common.parseMixed((node, input) => {\n        let id = node.type.id;\n        if (codeParser && (id == Type.CodeBlock || id == Type.FencedCode)) {\n            let info = \"\";\n            if (id == Type.FencedCode) {\n                let infoNode = node.node.getChild(Type.CodeInfo);\n                if (infoNode)\n                    info = input.read(infoNode.from, infoNode.to);\n            }\n            let parser = codeParser(info);\n            if (parser)\n                return { parser, overlay: node => node.type.id == Type.CodeText };\n        }\n        else if (htmlParser && (id == Type.HTMLBlock || id == Type.HTMLTag)) {\n            return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };\n        }\n        return null;\n    });\n    return { wrap };\n}\n\nconst StrikethroughDelim = { resolve: \"Strikethrough\", mark: \"StrikethroughMark\" };\n/// An extension that implements\n/// [GFM-style](https://github.github.com/gfm/#strikethrough-extension-)\n/// Strikethrough syntax using `~~` delimiters.\nconst Strikethrough = {\n    defineNodes: [{\n            name: \"Strikethrough\",\n            style: { \"Strikethrough/...\": highlight.tags.strikethrough }\n        }, {\n            name: \"StrikethroughMark\",\n            style: highlight.tags.processingInstruction\n        }],\n    parseInline: [{\n            name: \"Strikethrough\",\n            parse(cx, next, pos) {\n                if (next != 126 /* '~' */ || cx.char(pos + 1) != 126)\n                    return -1;\n                return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, true, true);\n            },\n            after: \"Emphasis\"\n        }]\n};\nfunction parseRow(cx, line, startI = 0, elts, offset = 0) {\n    let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;\n    let parseCell = () => {\n        elts.push(cx.elt(\"TableCell\", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));\n    };\n    for (let i = startI; i < line.length; i++) {\n        let next = line.charCodeAt(i);\n        if (next == 124 /* '|' */ && !esc) {\n            if (!first || cellStart > -1)\n                count++;\n            first = false;\n            if (elts) {\n                if (cellStart > -1)\n                    parseCell();\n                elts.push(cx.elt(\"TableDelimiter\", i + offset, i + offset + 1));\n            }\n            cellStart = cellEnd = -1;\n        }\n        else if (esc || next != 32 && next != 9) {\n            if (cellStart < 0)\n                cellStart = i;\n            cellEnd = i + 1;\n        }\n        esc = !esc && next == 92;\n    }\n    if (cellStart > -1) {\n        count++;\n        if (elts)\n            parseCell();\n    }\n    return count;\n}\nfunction hasPipe(str, start) {\n    for (let i = start; i < str.length; i++) {\n        let next = str.charCodeAt(i);\n        if (next == 124 /* '|' */)\n            return true;\n        if (next == 92 /* '\\\\' */)\n            i++;\n    }\n    return false;\n}\nconst delimiterLine = /^\\|?(\\s*:?-+:?\\s*\\|)+(\\s*:?-+:?\\s*)?$/;\nclass TableParser {\n    constructor() {\n        // Null means we haven't seen the second line yet, false means this\n        // isn't a table, and an array means this is a table and we've\n        // parsed the given rows so far.\n        this.rows = null;\n    }\n    nextLine(cx, line, leaf) {\n        if (this.rows == null) { // Second line\n            this.rows = false;\n            let lineText;\n            if ((line.next == 45 || line.next == 58 || line.next == 124 /* '-:|' */) &&\n                delimiterLine.test(lineText = line.text.slice(line.pos))) {\n                let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);\n                if (firstCount == parseRow(cx, lineText, line.pos))\n                    this.rows = [cx.elt(\"TableHeader\", leaf.start, leaf.start + leaf.content.length, firstRow),\n                        cx.elt(\"TableDelimiter\", cx.lineStart + line.pos, cx.lineStart + line.text.length)];\n            }\n        }\n        else if (this.rows) { // Line after the second\n            let content = [];\n            parseRow(cx, line.text, line.pos, content, cx.lineStart);\n            this.rows.push(cx.elt(\"TableRow\", cx.lineStart + line.pos, cx.lineStart + line.text.length, content));\n        }\n        return false;\n    }\n    finish(cx, leaf) {\n        if (!this.rows)\n            return false;\n        cx.addLeafElement(leaf, cx.elt(\"Table\", leaf.start, leaf.start + leaf.content.length, this.rows));\n        return true;\n    }\n}\n/// This extension provides\n/// [GFM-style](https://github.github.com/gfm/#tables-extension-)\n/// tables, using syntax like this:\n///\n/// ```\n/// | head 1 | head 2 |\n/// | ---    | ---    |\n/// | cell 1 | cell 2 |\n/// ```\nconst Table = {\n    defineNodes: [\n        { name: \"Table\", block: true },\n        { name: \"TableHeader\", style: { \"TableHeader/...\": highlight.tags.heading } },\n        \"TableRow\",\n        { name: \"TableCell\", style: highlight.tags.content },\n        { name: \"TableDelimiter\", style: highlight.tags.processingInstruction },\n    ],\n    parseBlock: [{\n            name: \"Table\",\n            leaf(_, leaf) { return hasPipe(leaf.content, 0) ? new TableParser : null; },\n            endLeaf(cx, line, leaf) {\n                if (leaf.parsers.some(p => p instanceof TableParser) || !hasPipe(line.text, line.basePos))\n                    return false;\n                let next = cx.scanLine(cx.absoluteLineEnd + 1).text;\n                return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);\n            },\n            before: \"SetextHeading\"\n        }]\n};\nclass TaskParser {\n    nextLine() { return false; }\n    finish(cx, leaf) {\n        cx.addLeafElement(leaf, cx.elt(\"Task\", leaf.start, leaf.start + leaf.content.length, [\n            cx.elt(\"TaskMarker\", leaf.start, leaf.start + 3),\n            ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)\n        ]));\n        return true;\n    }\n}\n/// Extension providing\n/// [GFM-style](https://github.github.com/gfm/#task-list-items-extension-)\n/// task list items, where list items can be prefixed with `[ ]` or\n/// `[x]` to add a checkbox.\nconst TaskList = {\n    defineNodes: [\n        { name: \"Task\", block: true, style: highlight.tags.list },\n        { name: \"TaskMarker\", style: highlight.tags.atom }\n    ],\n    parseBlock: [{\n            name: \"TaskList\",\n            leaf(cx, leaf) {\n                return /^\\[[ xX]\\]/.test(leaf.content) && cx.parentType().name == \"ListItem\" ? new TaskParser : null;\n            },\n            after: \"SetextHeading\"\n        }]\n};\n/// Extension bundle containing [`Table`](#Table),\n/// [`TaskList`](#TaskList) and [`Strikethrough`](#Strikethrough).\nconst GFM = [Table, TaskList, Strikethrough];\nfunction parseSubSuper(ch, node, mark) {\n    return (cx, next, pos) => {\n        if (next != ch || cx.char(pos + 1) == ch)\n            return -1;\n        let elts = [cx.elt(mark, pos, pos + 1)];\n        for (let i = pos + 1; i < cx.end; i++) {\n            let next = cx.char(i);\n            if (next == ch)\n                return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));\n            if (next == 92 /* '\\\\' */)\n                elts.push(cx.elt(\"Escape\", i, i++ + 2));\n            if (space(next))\n                break;\n        }\n        return -1;\n    };\n}\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// superscript using `^` markers.\nconst Superscript = {\n    defineNodes: [\n        { name: \"Superscript\", style: highlight.tags.special(highlight.tags.content) },\n        { name: \"SuperscriptMark\", style: highlight.tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Superscript\",\n            parse: parseSubSuper(94 /* '^' */, \"Superscript\", \"SuperscriptMark\")\n        }]\n};\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// subscript using `~` markers.\nconst Subscript = {\n    defineNodes: [\n        { name: \"Subscript\", style: highlight.tags.special(highlight.tags.content) },\n        { name: \"SubscriptMark\", style: highlight.tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Subscript\",\n            parse: parseSubSuper(126 /* '~' */, \"Subscript\", \"SubscriptMark\")\n        }]\n};\n/// Extension that parses two colons with only letters, underscores,\n/// and numbers between them as `Emoji` nodes.\nconst Emoji = {\n    defineNodes: [{ name: \"Emoji\", style: highlight.tags.character }],\n    parseInline: [{\n            name: \"Emoji\",\n            parse(cx, next, pos) {\n                let match;\n                if (next != 58 /* ':' */ || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))\n                    return -1;\n                return cx.addElement(cx.elt(\"Emoji\", pos, pos + 1 + match[0].length));\n            }\n        }]\n};\n\nexports.BlockContext = BlockContext;\nexports.Element = Element;\nexports.Emoji = Emoji;\nexports.GFM = GFM;\nexports.InlineContext = InlineContext;\nexports.LeafBlock = LeafBlock;\nexports.Line = Line;\nexports.MarkdownParser = MarkdownParser;\nexports.Strikethrough = Strikethrough;\nexports.Subscript = Subscript;\nexports.Superscript = Superscript;\nexports.Table = Table;\nexports.TaskList = TaskList;\nexports.parseCode = parseCode;\nexports.parser = parser;\n\n};"],
"names":["shadow$provide","global","require","module","exports","skipForList","bl","cx","line","pos","text","length","block","indent","stack","depth","value","baseIndent","size","type","Type","OrderedList","isOrderedList","isBulletList","BulletList","isHorizontalRule","charCodeAt","space","ch","skipSpace","i","skipSpaceBack","to","isFencedCode","next","breaking","count","isSetextUnderline","inList","isAtxHeading","end","isHTMLBlock","_cx","rest","slice","e","HTMLBlockStyle","test","getListIndent","indentAfter","countIndent","indented","addCodeText","marks","from","last","CodeText","push","elt","lineEnd","injectGaps","ranges","rangeI","tree","offset","dont","movePastNext","upto","inclusive","rangeEnd","has","children","positions","start","firstChild","nextSibling","node","toTree","common","Tree","propValues","undefined","nonEmpty","a","resolveConfig","spec","Array","isArray","conf","wrapA","wrap","wrapB","props","concat","none","defineNodes","parseBlock","parseInline","remove","inner","input","fragments","findName","names","name","found","indexOf","RangeError","Element","parseURL","URL","escaped","parseLinkTitle","LinkTitle","parseLinkLabel","requireNonWS","Math","min","LinkLabel","injectMarks","elements","elts","eI","mark","splice","leftOverSpace","n","nextPos","parseRow","startI","first","cellStart","cellEnd","esc","parseCell","parser","hasPipe","str","parseSubSuper","char","addElement","Object","defineProperty","highlight","CompositeBlock","constructor","hash","hashProp","NodeProp","contextHash","create","parentHash","addChild","child","prop","nodeSet","max","balance","types","makeTree","NodeType","LeafBlock","content","parsers","Line","basePos","markers","forward","forwardInner","newPos","reset","pop","moveBase","moveBaseColumn","findColumn","addMarker","goal","scrub","result","DefaultSkipMarkup","Blockquote","QuoteMark","lineStart","ListItem","Document","EmptyLine","CommentEnd","ProcessingEnd","DefaultBlockParsers","LinkReference","IndentedCode","base","pendingMarks","nextLine","m","codeStart","filter","addNode","buffer","writeElements","finish","CodeBlock","FencedCode","fenceEnd","len","infoFrom","infoTo","CodeMark","CodeInfo","textStart","textEnd","prevLineEnd","startContext","HorizontalRule","newBase","ListMark","ATXHeading","off","endOfSpace","after","buf","write","HeaderMark","ATXHeading1","HTMLBlock","trailing","nodeType","CommentBlock","ProcessingInstructionBlock","SetextHeading","LinkReferenceParser","leaf","stage","advance","complete","addLeafElement","nextStage","LinkMark","skip","title","titleEnd","SetextHeadingParser","underline","underlineMark","SetextHeading1","SetextHeading2","DefaultLeafBlocks","_","scanLineResult","BlockContext","atEnd","dontInject","Set","stoppedAt","absoluteLineStart","absoluteLineEnd","FragmentCursor","readLine","finishContext","reuseFragment","blockParsers","parse","leafBlockParsers","stop","endLeafBlock","finishLeaf","stopAt","moveTo","matches","taken","takeNodes","withoutGaps","gapFrom","gapTo","moveRangeI","parentType","scanLine","lineChunkAt","textOffset","nextFrom","handler","skipContextMarkup","Error","chunk","lineChunks","eol","startComposite","getNodeType","top","addGaps","topNode","inline","Paragraph","TreeElement","Buffer","MarkdownParser","Parser","blockNames","inlineParsers","inlineNames","wrappers","nodeTypes","t","id","createParse","w","configure","config","assign","styles","s","composite","style","some","group","define","Tag","NodeSet","extend","styleTags","rm","before","endLeaf","InlineContext","token","resolveMarkers","Escape","nodes","writeTo","build","reused","topID","startOff","EmphasisUnderscore","resolve","EmphasisAsterisk","LinkStart","ImageStart","InlineDelimiter","side","Punctuation","DefaultInline","Escapable","append","Entity","exec","InlineCode","curSize","HTMLTag","url","comment","Comment","procInst","ProcessingInstruction","Emphasis","pBefore","pAfter","sBefore","sAfter","leftFlanking","rightFlanking","HardBreak","Link","Image","LinkEnd","parts","part","takeContent","startPos","endPos","unshift","dest","label","link","j","p","addDelimiter","open","close","emp","closeSize","k","element","findOpeningDelimiter","startIndex","NotLast","fragment","fragmentEnd","cursor","nextFragment","read","c","rPos","parent","childAfter","cur","fragEnd","openEnd","blockI","prevEnd","prevI","isAnonymous","add","is","markdownHighlighting","tags","quote","contentSeparator","heading1","heading2","heading3","heading4","heading5","heading6","escape","character","emphasis","strong","list","monospace","processingInstruction","labelName","string","keys","map","DefaultEndLeaf","StrikethroughDelim","Strikethrough","strikethrough","delimiterLine","TableParser","rows","lineText","firstRow","firstCount","Table","heading","TaskParser","TaskList","atom","GFM","Superscript","special","Subscript","Emoji","match","parseCode","codeParser","htmlParser","parseMixed","info","infoNode","getChild","overlay"]
}
