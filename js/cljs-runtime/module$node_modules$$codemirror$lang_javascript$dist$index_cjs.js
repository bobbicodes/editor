shadow$provide.module$node_modules$$codemirror$lang_javascript$dist$index_cjs=function(global,require,module,exports){function defID(type){return(node,def)=>{(node=node.node.getChild("VariableDefinition"))&&def(node,type);return!0}}function getScope(doc,node$jscomp$0){function def(node,type){node=doc.sliceString(node.from,node.to);completions.push({label:node,type})}let cached=cache.get(node$jscomp$0);if(cached)return cached;let completions=[],top=!0;node$jscomp$0.cursor(common.IterMode.IncludeAnonymous).iterate(node=>
{if(top)top=!1;else if(node.name){var gather=gatherCompletions[node.name];if(gather&&gather(node,def)||ScopeNodes.has(node.name))return!1}else if(8192<node.to-node.from){for(gather of getScope(doc,node.node))completions.push(gather);return!1}});cache.set(node$jscomp$0,completions);return completions}function localCompletionSource(context){let inner=language.syntaxTree(context.state).resolveInner(context.pos,-1);if(-1<dontComplete.indexOf(inner.name))return null;let isWord=20>inner.to-inner.from&&
Identifier.test(context.state.sliceDoc(inner.from,inner.to));if(!isWord&&!context.explicit)return null;let options=[];for(let pos=inner;pos;pos=pos.parent)ScopeNodes.has(pos.name)&&(options=options.concat(getScope(context.state.doc,pos)));return{options,from:isWord?inner.from:context.pos,validFor:Identifier}}function elementName(doc,tree,max=doc.length){return tree?(tree=tree.getChild("JSXIdentifier"))?doc.sliceString(tree.from,Math.min(tree.to,max)):"":""}function mapPos(line,col,doc,offset){return doc.line(line+
offset.line).from+col+(1==line?offset.col-1:-1)}function translateDiagnostic(input,doc,offset){let start$jscomp$0=mapPos(input.line,input.column,doc,offset);doc={from:start$jscomp$0,to:null!=input.endLine&&1!=input.endColumn?mapPos(input.endLine,input.endColumn,doc,offset):start$jscomp$0,message:input.message,source:input.ruleId?"jshint:"+input.ruleId:"jshint",severity:1==input.severity?"warning":"error"};if(input.fix){let {range,text}=input.fix,from=range[0]+offset.pos-start$jscomp$0,to=range[1]+
offset.pos-start$jscomp$0;doc.actions=[{name:"fix",apply(view,start){view.dispatch({changes:{from:start+from,to:start+to,insert:text},scrollIntoView:!0})}}]}return doc}Object.defineProperty(exports,"__esModule",{value:!0});global=require("module$node_modules$$lezer$javascript$dist$index_cjs");var language=require("module$node_modules$$codemirror$language$dist$index_cjs"),state=require("module$node_modules$$codemirror$state$dist$index_cjs");module=require("module$node_modules$$codemirror$view$dist$index_cjs");
var autocomplete=require("module$node_modules$$codemirror$autocomplete$dist$index_cjs"),common=require("module$node_modules$$lezer$common$dist$index_cjs");const snippets=[autocomplete.snippetCompletion("function ${name}(${params}) {\n\t${}\n}",{label:"function",detail:"definition",type:"keyword"}),autocomplete.snippetCompletion("for (let ${index} \x3d 0; ${index} \x3c ${bound}; ${index}++) {\n\t${}\n}",{label:"for",detail:"loop",type:"keyword"}),autocomplete.snippetCompletion("for (let ${name} of ${collection}) {\n\t${}\n}",
{label:"for",detail:"of loop",type:"keyword"}),autocomplete.snippetCompletion("do {\n\t${}\n} while (${})",{label:"do",detail:"loop",type:"keyword"}),autocomplete.snippetCompletion("while (${}) {\n\t${}\n}",{label:"while",detail:"loop",type:"keyword"}),autocomplete.snippetCompletion("try {\n\t${}\n} catch (${error}) {\n\t${}\n}",{label:"try",detail:"/ catch block",type:"keyword"}),autocomplete.snippetCompletion("if (${}) {\n\t${}\n}",{label:"if",detail:"block",type:"keyword"}),autocomplete.snippetCompletion("if (${}) {\n\t${}\n} else {\n\t${}\n}",
{label:"if",detail:"/ else block",type:"keyword"}),autocomplete.snippetCompletion("class ${name} {\n\tconstructor(${params}) {\n\t\t${}\n\t}\n}",{label:"class",detail:"definition",type:"keyword"}),autocomplete.snippetCompletion('import {${names}} from "${module}"\n${}',{label:"import",detail:"named",type:"keyword"}),autocomplete.snippetCompletion('import ${name} from "${module}"\n${}',{label:"import",detail:"default",type:"keyword"})],cache=new common.NodeWeakMap,ScopeNodes=new Set("Script Block FunctionExpression FunctionDeclaration ArrowFunction MethodDeclaration ForStatement".split(" ")),
functionContext=["FunctionDeclaration"],gatherCompletions={FunctionDeclaration:defID("function"),ClassDeclaration:defID("class"),ClassExpression:()=>!0,EnumDeclaration:defID("constant"),TypeAliasDeclaration:defID("type"),NamespaceDeclaration:defID("namespace"),VariableDefinition(node,def){node.matchContext(functionContext)||def(node,"variable")},TypeDefinition(node,def){def(node,"type")},__proto__:null},Identifier=/^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/,dontComplete="TemplateString String RegExp LineComment BlockComment VariableDefinition TypeDefinition Label PropertyDefinition PropertyName PrivatePropertyDefinition PrivatePropertyName".split(" "),
javascriptLanguage=language.LRLanguage.define({parser:global.parser.configure({props:[language.indentNodeProp.add({IfStatement:language.continuedIndent({except:/^\s*({|else\b)/}),TryStatement:language.continuedIndent({except:/^\s*({|catch\b|finally\b)/}),LabeledStatement:language.flatIndent,SwitchBody:context=>{var after=context.textAfter;let closed=/^\s*\}/.test(after);after=/^\s*(case|default)\b/.test(after);return context.baseIndent+(closed?0:after?1:2)*context.unit},Block:language.delimitedIndent({closing:"}"}),
ArrowFunction:cx=>cx.baseIndent+cx.unit,"TemplateString BlockComment":()=>-1,"Statement Property":language.continuedIndent({except:/^{/}),JSXElement(context){let closed=/^\s*<\//.test(context.textAfter);return context.lineIndent(context.node.from)+(closed?0:context.unit)},JSXEscape(context){let closed=/\s*\}/.test(context.textAfter);return context.lineIndent(context.node.from)+(closed?0:context.unit)},["JSXOpenTag JSXSelfClosingTag"](context){return context.column(context.node.from)+context.unit}}),
language.foldNodeProp.add({"Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression":language.foldInside,BlockComment(tree){return{from:tree.from+2,to:tree.to-2}}})]}),languageData:{closeBrackets:{brackets:"([{'\"`".split("")},commentTokens:{line:"//",block:{open:"/*",close:"*/"}},indentOnInput:/^\s*(?:case |default:|\{|\}|<\/)$/,wordChars:"$"}}),typescriptLanguage=javascriptLanguage.configure({dialect:"ts"}),jsxLanguage=javascriptLanguage.configure({dialect:"jsx"}),tsxLanguage=javascriptLanguage.configure({dialect:"jsx ts"}),
keywords="break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(kw=>({label:kw,type:"keyword"})),android="object"==typeof navigator&&/Android\b/.test(navigator.userAgent),autoCloseTags=module.EditorView.inputHandler.of((view,from,to,text)=>{if((android?view.composing:view.compositionStarted)||view.state.readOnly||from!=to||"\x3e"!=text&&"/"!=text||!javascriptLanguage.isActiveAt(view.state,
from,-1))return!1;let {state:state$1}=view;from=state$1.changeByRange(range=>{var _a,_b,_c;let {head}=range,around=language.syntaxTree(state$1).resolveInner(head,-1),name;"JSXStartTag"==around.name&&(around=around.parent);if("\x3e"==text&&"JSXFragmentTag"==around.name)return{range:state.EditorSelection.cursor(head+1),changes:{from:head,insert:"\x3e\x3c\x3e"}};if("\x3e"==text&&"JSXIdentifier"==around.name){if("JSXEndTag"!=(null===(_b=null===(_a=around.parent)||void 0===_a?void 0:_a.lastChild)||void 0===
_b?void 0:_b.name)&&(name=elementName(state$1.doc,around.parent,head)))return{range:state.EditorSelection.cursor(head+1),changes:{from:head,insert:`></${name}>`}}}else if("/"==text&&"JSXFragmentTag"==around.name&&(_a=around.parent,_b=null===_a||void 0===_a?void 0:_a.parent,_a.from==head-1&&"JSXEndTag"!=(null===(_c=_b.lastChild)||void 0===_c?void 0:_c.name)&&(name=elementName(state$1.doc,null===_b||void 0===_b?void 0:_b.firstChild,head))))return range=`/${name}>`,{range:state.EditorSelection.cursor(head+
range.length),changes:{from:head,insert:range}};return{range}});if(from.changes.empty)return!1;view.dispatch(from,{userEvent:"input.type",scrollIntoView:!0});return!0});exports.autoCloseTags=autoCloseTags;exports.esLint=function(eslint,config){config||(config={parserOptions:{ecmaVersion:2019,sourceType:"module"},env:{browser:!0,node:!0,es6:!0,es2015:!0,es2017:!0,es2020:!0},rules:{}},eslint.getRules().forEach((desc,name)=>{desc.meta.docs.recommended&&(config.rules[name]=2)}));return view=>{({state:view}=
view);let found=[];for(let {from,to}of javascriptLanguage.findRegions(view)){var fromLine=view.doc.lineAt(from);fromLine={line:fromLine.number-1,col:from-fromLine.from,pos:from};for(let d of eslint.verify(view.sliceDoc(from,to),config))found.push(translateDiagnostic(d,view.doc,fromLine))}return found}};exports.javascript=function(config={}){return new language.LanguageSupport(config.jsx?config.typescript?tsxLanguage:jsxLanguage:config.typescript?typescriptLanguage:javascriptLanguage,[javascriptLanguage.data.of({autocomplete:autocomplete.ifNotIn(dontComplete,
autocomplete.completeFromList(snippets.concat(keywords)))}),javascriptLanguage.data.of({autocomplete:localCompletionSource}),config.jsx?autoCloseTags:[]])};exports.javascriptLanguage=javascriptLanguage;exports.jsxLanguage=jsxLanguage;exports.localCompletionSource=localCompletionSource;exports.snippets=snippets;exports.tsxLanguage=tsxLanguage;exports.typescriptLanguage=typescriptLanguage}
//# sourceMappingURL=module$node_modules$$codemirror$lang_javascript$dist$index_cjs.js.map
