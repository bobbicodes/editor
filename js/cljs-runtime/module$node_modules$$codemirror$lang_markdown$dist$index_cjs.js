shadow$provide.module$node_modules$$codemirror$lang_markdown$dist$index_cjs=function(global,require,module,exports){function getCodeParser(languages,defaultLanguage){return info=>{if(info&&languages){info="function"==typeof languages?languages(info):language.LanguageDescription.matchLanguageName(languages,info,!0);if(info instanceof language.LanguageDescription)return info.support?info.support.language.parser:language.ParseContext.getSkippingParser(info.load());if(info)return info.parser}return defaultLanguage?
defaultLanguage.parser:null}}function getContext(node$jscomp$0,line,doc){let nodes=[];for(;node$jscomp$0&&"Document"!=node$jscomp$0.name;node$jscomp$0=node$jscomp$0.parent)"ListItem"!=node$jscomp$0.name&&"Blockquote"!=node$jscomp$0.name||nodes.push(node$jscomp$0);node$jscomp$0=[];let pos=0;for(let i=nodes.length-1;0<=i;i--){let node=nodes[i],match,start=pos;if("Blockquote"==node.name&&(match=/^[ \t]*>( ?)/.exec(line.slice(pos))))pos+=match[0].length,node$jscomp$0.push(new Context(node,start,pos,"",
match[1],"\x3e",null));else if("ListItem"==node.name&&"OrderedList"==node.parent.name&&(match=/^([ \t]*)\d+([.)])([ \t]*)/.exec(doc.sliceString(node.from,node.from+50)))){var after=match[3],len=match[0].length;4<=after.length&&(after=after.slice(0,after.length-4),len-=4);pos+=len;node$jscomp$0.push(new Context(node.parent,start,pos,match[1],after,match[2],node))}else if("ListItem"==node.name&&"BulletList"==node.parent.name&&(match=/^([ \t]*)([-+*])([ \t]{1,4}\[[ xX]\])?([ \t]+)/.exec(doc.sliceString(node.from,
node.from+50)))){after=match[4];len=match[0].length;4<after.length&&(after=after.slice(0,after.length-4),len-=4);let type=match[2];match[3]&&(type+=match[3].replace(/[xX]/," "));pos+=len;node$jscomp$0.push(new Context(node.parent,start,pos,match[1],after,type,node))}}return node$jscomp$0}function itemNumber(item,doc){return/^(\s*)(\d+)(?=[.)])/.exec(doc.sliceString(item.from,item.from+10))}function renumberList(after,doc,changes,offset=0){for(let prev=-1,node=after;;){if("ListItem"==node.name){after=
itemNumber(node,doc);let number=+after[2];if(0<=prev){if(number!=prev+1)break;changes.push({from:node.from+after[1].length,to:node.from+after[0].length,insert:String(prev+2+offset)})}prev=number}after=node.nextSibling;if(!after)break;node=after}}function isMark(node){return"QuoteMark"==node.name||"ListMark"==node.name}Object.defineProperty(exports,"__esModule",{value:!0});var state$jscomp$0=require("module$node_modules$$codemirror$state$dist$index_cjs"),view=require("module$node_modules$$codemirror$view$dist$index_cjs"),
language=require("module$node_modules$$codemirror$language$dist$index_cjs"),markdown$1=require("module$node_modules$$lezer$markdown$dist$index_cjs");global=require("module$node_modules$$codemirror$lang_html$dist$index_cjs");const data=language.defineLanguageFacet({block:{open:"\x3c!--",close:"--\x3e"}});require=markdown$1.parser.configure({props:[language.foldNodeProp.add(type=>{if(type.is("Block")&&!type.is("Document"))return(tree,state)=>({from:state.doc.lineAt(tree.from).to,to:tree.to})}),language.indentNodeProp.add({Document:()=>
null}),language.languageDataProp.add({Document:data})]});const commonmarkLanguage=new language.Language(data,require);require=require.configure([markdown$1.GFM,markdown$1.Subscript,markdown$1.Superscript,markdown$1.Emoji]);const markdownLanguage=new language.Language(data,require);class Context{constructor(node,from,to,spaceBefore,spaceAfter,type,item){this.node=node;this.from=from;this.to=to;this.spaceBefore=spaceBefore;this.spaceAfter=spaceAfter;this.type=type;this.item=item}blank(trailing=!0){let result=
this.spaceBefore;if("Blockquote"==this.node.name)result+="\x3e";else for(let i=this.to-this.from-result.length-this.spaceAfter.length;0<i;i--)result+=" ";return result+(trailing?this.spaceAfter:"")}marker(doc,add){doc="OrderedList"==this.node.name?String(+itemNumber(this.item,doc)[2]+add):"";return this.spaceBefore+doc+this.type+this.spaceAfter}}require=({state:state$1,dispatch})=>{let tree=language.syntaxTree(state$1),{doc}=state$1,dont=null,changes=state$1.changeByRange(range=>{if(!range.empty||
!markdownLanguage.isActiveAt(state$1,range.from))return dont={range};for(var pos=range.from,line=doc.lineAt(pos),context=getContext(tree.resolveInner(pos,-1),line.text,doc);context.length&&context[context.length-1].from>pos-line.from;)context.pop();if(!context.length)return dont={range};var inner=context[context.length-1];if(inner.to-inner.spaceAfter.length>pos-line.from)return dont={range};var emptyLine=pos>=inner.to-inner.spaceAfter.length&&!/\S/.test(line.text.slice(inner.to));if(inner.item&&emptyLine){if(inner.node.firstChild.to>=
pos||0<line.from&&!/[^\s>]/.test(doc.lineAt(line.from-1).text))return context=1<context.length?context[context.length-2]:null,range="",context&&context.item?(line=line.from+context.from,range=context.marker(doc,1)):line=line.from+(context?context.to:0),pos=[{from:line,to:pos,insert:range}],"OrderedList"==inner.node.name&&renumberList(inner.item,doc,pos,-2),context&&"OrderedList"==context.node.name&&renumberList(context.item,doc,pos),{range:state$jscomp$0.EditorSelection.cursor(line+range.length),
changes:pos};inner="";for(let i=0,e=context.length-2;i<=e;i++)inner+=context[i].blank(i<e);inner+=state$1.lineBreak;return{range:state$jscomp$0.EditorSelection.cursor(pos+inner.length),changes:{from:line.from,insert:inner}}}if("Blockquote"==inner.node.name&&emptyLine&&line.from){emptyLine=doc.lineAt(line.from-1);var quoted=/>\s*$/.exec(emptyLine.text);if(quoted&&quoted.index==inner.from)return pos=state$1.changes([{from:emptyLine.from+quoted.index,to:emptyLine.to},{from:line.from+inner.from,to:line.to}]),
{range:range.map(pos),changes:pos}}range=[];"OrderedList"==inner.node.name&&renumberList(inner.item,doc,range);emptyLine=state$1.lineBreak;quoted=inner.item&&inner.item.from<line.from;if(!quoted||/^[\s\d.)\-+*>]*/.exec(line.text)[0].length>=inner.to)for(let i=0,e=context.length-1;i<=e;i++)emptyLine+=i!=e||quoted?context[i].blank():context[i].marker(doc,1);for(inner=pos;inner>line.from&&/\s/.test(line.text.charAt(inner-line.from-1));)inner--;range.push({from:inner,to:pos,insert:emptyLine});return{range:state$jscomp$0.EditorSelection.cursor(inner+
emptyLine.length),changes:range}});if(dont)return!1;dispatch(state$1.update(changes,{scrollIntoView:!0,userEvent:"input"}));return!0};module=({state:state$1,dispatch})=>{let tree=language.syntaxTree(state$1),dont=null,changes=state$1.changeByRange(range=>{let pos=range.from;var {doc}=state$1;if(range.empty&&markdownLanguage.isActiveAt(state$1,range.from)){let line=doc.lineAt(pos);var node=tree.resolveInner(pos,-1),scan=pos;isMark(node)&&(scan=node.from,node=node.parent);for(;scan=node.childBefore(scan);)if(isMark(scan))scan=
scan.from;else if("OrderedList"==scan.name||"BulletList"==scan.name)node=scan.lastChild,scan=node.to;else break;doc=getContext(node,line.text,doc);if(doc.length){doc=doc[doc.length-1];node=doc.to-doc.spaceAfter.length+(doc.spaceAfter?1:0);if(pos-line.from>node&&!/\S/.test(line.text.slice(node,pos-line.from)))return{range:state$jscomp$0.EditorSelection.cursor(line.from+node),changes:{from:line.from+node,to:pos}};if(pos-line.from==node){node=line.from+doc.from;if(doc.item&&doc.node.from<doc.item.from&&
/\S/.test(line.text.slice(doc.from,doc.to)))return{range,changes:{from:node,to:line.from+doc.to,insert:doc.blank()}};if(node<pos)return{range:state$jscomp$0.EditorSelection.cursor(node),changes:{from:node,to:pos}}}}}return dont={range}});if(dont)return!1;dispatch(state$1.update(changes,{scrollIntoView:!0,userEvent:"delete"}));return!0};const markdownKeymap=[{key:"Enter",run:require},{key:"Backspace",run:module}],htmlNoMatch=global.html({matchClosingTags:!1});exports.commonmarkLanguage=commonmarkLanguage;
exports.deleteMarkupBackward=module;exports.insertNewlineContinueMarkup=require;exports.markdown=function(config={}){let {codeLanguages,defaultCodeLanguage,addKeymap=!0,base:{parser}=commonmarkLanguage}=config;if(!(parser instanceof markdown$1.MarkdownParser))throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");config=config.extensions?[config.extensions]:[];let support=[htmlNoMatch.support];if(defaultCodeLanguage instanceof language.LanguageSupport){support.push(defaultCodeLanguage.support);
var defaultCode=defaultCodeLanguage.language}else defaultCodeLanguage&&(defaultCode=defaultCodeLanguage);defaultCode=codeLanguages||defaultCode?getCodeParser(codeLanguages,defaultCode):void 0;config.push(markdown$1.parseCode({codeParser:defaultCode,htmlParser:htmlNoMatch.language.parser}));addKeymap&&support.push(state$jscomp$0.Prec.high(view.keymap.of(markdownKeymap)));return new language.LanguageSupport(new language.Language(data,parser.configure(config)),support)};exports.markdownKeymap=markdownKeymap;
exports.markdownLanguage=markdownLanguage}
//# sourceMappingURL=module$node_modules$$codemirror$lang_markdown$dist$index_cjs.js.map
