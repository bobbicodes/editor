{"version":3,"sources":["nextjournal/clojure_mode/extensions/match_brackets.cljs"],"mappings":"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","names":["nextjournal.clojure-mode.extensions.match-brackets/base-theme","js/module$node_modules$$codemirror$view$dist$index_cjs.EditorView","nextjournal.clojure-mode.extensions.match-brackets/matching-mark","js/module$node_modules$$codemirror$view$dist$index_cjs.Decoration","nextjournal.clojure-mode.extensions.match-brackets/nonmatching-mark","nextjournal.clojure-mode.extensions.match-brackets/mark-node","node","mark","nextjournal.clojure-mode.node/start","nextjournal.clojure-mode.node/end","nextjournal.clojure-mode.extensions.match-brackets/state","cljs.core/constantly","p__60288","map__60289","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","obj60292","js/undefined","obj60294","obj60296","deco","tr","state","docChanged","selection","or__4223__auto__","decos","cljs.core.reduce","p__60297","map__60298","obj60304","obj60306","out","head","empty","temp__5753__auto__","bracket","and__4221__auto__","nextjournal.clojure_mode.node.tree","cljs.core.filter","cljs.core.some_fn","nextjournal.clojure-mode.node/start-edge?","nextjournal.clojure-mode.node/end-edge?","cljs.core/first","temp__5751__auto__","other-bracket","cljs.core._EQ_","nextjournal.clojure-mode.node/up","nextjournal.clojure-mode.node/down-last","p1__60286#","nextjournal.clojure-mode.util/guard","nextjournal.clojure-mode.node/name","nextjournal.clojure-mode.node/closed-by","nextjournal.clojure-mode.node/down","p1__60287#","nextjournal.clojure-mode.node/opened-by","cljs.core.conj","unparsed-bracket","cljs.core/not","nextjournal.clojure-mode.node/closest","nextjournal.clojure-mode.node/string?","G__60324","fexpr__60323","nextjournal.clojure_mode.node.from_to","cljs.core.into_array","js/module$node_modules$$codemirror$state$dist$index_cjs.StateField","nextjournal.clojure-mode.extensions.match-brackets/extension"],"sourcesContent":["(ns nextjournal.clojure-mode.extensions.match-brackets\r\n  (:require\r\n   [\"@codemirror/state\" :refer [EditorState\r\n                                StateField\r\n                                Extension]]\r\n   [\"@codemirror/view\" :refer [EditorView\r\n                               Decoration DecorationSet]]\r\n   [applied-science.js-interop :as j]\r\n   [nextjournal.clojure-mode.node :as n]\r\n   [nextjournal.clojure-mode.util :as u]))\r\n\r\n(def base-theme\r\n  (->>\r\n    (j/lit {:$matchingBracket {:color \"#0b0\"}\r\n            :$nonmatchingBracket {:color \"#a22\"}})\r\n    (.baseTheme EditorView)))\r\n\r\n(def ^js matching-mark (.mark Decoration (j/obj :class \"cm-matchingBracket\")))\r\n(def ^js nonmatching-mark (.mark Decoration (j/obj :class \"cm-nonmatchingBracket\")))\r\n\r\n(defn mark-node [node ^js mark]\r\n  (.range mark (n/start node) (n/end node)))\r\n\r\n(def state\r\n  (->>\r\n   (j/lit\r\n    {:create (constantly (.-none Decoration))\r\n     :update (j/fn [deco ^:js {:as tr :keys [state docChanged selection]}]\r\n               (if (or docChanged selection)\r\n                 (let [decos (->> (.. tr -state -selection -ranges)\r\n                                  (reduce\r\n                                   (j/fn [out ^:js {:keys [head empty]}]\r\n                                     (or\r\n                                      ;; a parsed bracket is found before/after cursor\r\n                                      (when-let [bracket (and empty\r\n                                                              (->> [(n/tree state head -1) (n/tree state head 1)]\r\n                                                                   (filter (some-fn n/start-edge? n/end-edge?))\r\n                                                                   first))]\r\n                                        ;; try finding a matching bracket\r\n                                        (if-let [other-bracket (cond\r\n\r\n                                                                 ;; are we at starting position?\r\n                                                                 (and (n/start-edge? bracket)\r\n                                                                      (= (n/start bracket)\r\n                                                                         (n/start (n/up bracket))))\r\n                                                                 ;; get end-bracket\r\n                                                                 (-> bracket n/up n/down-last\r\n                                                                     (u/guard #(= (n/name %)\r\n                                                                                  (n/closed-by bracket))))\r\n\r\n                                                                 ;; are we at ending position?\r\n                                                                 (and (n/end-edge? bracket)\r\n                                                                      (= (n/end bracket)\r\n                                                                         (n/end (n/up bracket))))\r\n                                                                 ;; get start-bracket\r\n                                                                 (-> bracket n/up n/down\r\n                                                                     (u/guard #(= (n/name %)\r\n                                                                                  (n/opened-by bracket)))))]\r\n                                          (conj out\r\n                                                (mark-node bracket matching-mark)\r\n                                                (mark-node other-bracket matching-mark))\r\n                                          (conj out (mark-node bracket nonmatching-mark))))\r\n                                      ;; lezer does not produce tokens for non-matching close-brackets\r\n                                      ;; (we haven't entered a collection, so brackets are not valid tokens\r\n                                      ;;  and aren't parsed). So we need to check the string to see if an\r\n                                      ;; unmatched bracket is sitting in front of the cursor.\r\n                                      (when-let [unparsed-bracket (and\r\n                                                                   ;; skip this check if we're inside a string\r\n                                                                   (not (-> (n/tree state head) (n/closest n/string?)))\r\n                                                                   (-> (.. tr -state -doc (slice head (inc head)) toString)\r\n                                                                       (#{\\] \\) \\}})))]\r\n                                        (conj out (mark-node (n/from-to head (inc head)) nonmatching-mark)))\r\n                                      out)) []))]\r\n                   (.set Decoration (into-array decos) true))\r\n                 deco))})\r\n   (.define StateField)))\r\n\r\n(defn extension []\r\n  #js[base-theme\r\n      state\r\n      (.. EditorView -decorations (from state))])\r\n"]}